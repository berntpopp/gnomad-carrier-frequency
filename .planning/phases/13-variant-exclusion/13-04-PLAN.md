---
phase: 13-variant-exclusion
plan: 04
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - package.json
  - src/types/export.ts
  - src/types/url-state.ts
  - src/utils/export-utils.ts
  - src/utils/exclusion-url.ts
  - src/composables/useUrlState.ts
autonomous: true

must_haves:
  truths:
    - "Export includes excluded variants marked with status and reason"
    - "URL can encode excluded variant IDs via lz-string compression"
    - "Shared URLs restore exclusion state when opened"
    - "Too-long exclusion lists trigger warning and omit from URL"
  artifacts:
    - path: "package.json"
      provides: "lz-string dependency"
      contains: "lz-string"
    - path: "src/types/export.ts"
      provides: "ExportVariant with exclusion fields"
      contains: "excluded"
    - path: "src/utils/exclusion-url.ts"
      provides: "URL compression utilities"
      exports: ["encodeExclusions", "decodeExclusions"]
    - path: "src/composables/useUrlState.ts"
      provides: "URL state with exclusion sync"
      contains: "excl"
  key_links:
    - from: "src/utils/exclusion-url.ts"
      to: "lz-string"
      via: "import"
      pattern: "from 'lz-string'"
    - from: "src/composables/useUrlState.ts"
      to: "src/utils/exclusion-url.ts"
      via: "import"
      pattern: "encodeExclusions|decodeExclusions"
---

<objective>
Extend export and URL state to include exclusion data: add excluded/reason fields to export, add lz-string compression for URL sharing of exclusions.

Purpose: Enables exported data to include exclusion status (EXCL-06) and shared URLs to preserve exclusion state. Uses lz-string for efficient URL encoding with graceful fallback for large exclusion sets.

Output:
- Updated `package.json` with lz-string dependency
- Modified `src/types/export.ts` with exclusion fields
- New `src/utils/exclusion-url.ts` for URL compression
- Modified `src/composables/useUrlState.ts` for exclusion sync
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-variant-exclusion/13-CONTEXT.md
@.planning/phases/13-variant-exclusion/13-RESEARCH.md
@.planning/phases/13-variant-exclusion/13-01-SUMMARY.md
@src/types/export.ts
@src/types/url-state.ts
@src/utils/export-utils.ts
@src/composables/useUrlState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lz-string and extend export types</name>
  <files>
    package.json
    src/types/export.ts
    src/utils/export-utils.ts
  </files>
  <action>
1. Install lz-string dependency:
```bash
bun add lz-string
```

Note: lz-string v1.5.0+ includes TypeScript types - do NOT install @types/lz-string.

2. Modify `src/types/export.ts` to add exclusion fields to ExportVariant:
```typescript
/**
 * Variant row for export
 */
export interface ExportVariant {
  variantId: string;
  consequence: string;
  alleleFrequency: number | null;
  alleleFrequencyPercent: string;
  alleleCount: number;
  alleleNumber: number;
  hgvsC: string | null;
  hgvsP: string | null;
  clinvarStatus: string | null;
  isLoF: boolean;
  isClinvarPathogenic: boolean;
  // Exclusion fields (EXCL-06)
  excluded: boolean;
  exclusionReason: string | null;
}
```

3. Modify `src/utils/export-utils.ts` to include exclusion data:

Update the buildExportVariants function signature:
```typescript
import type { ExclusionReason } from '@/types';
import { EXCLUSION_REASONS } from '@/config/exclusion-reasons';

/**
 * Format exclusion reason for export display
 */
function formatExclusionReason(reason: ExclusionReason | undefined): string | null {
  if (!reason) return null;

  // Find the label for predefined reason
  const predefined = EXCLUSION_REASONS.find(r => r.value === reason.type);
  const label = predefined?.label ?? reason.type;

  // For 'other', append custom text if provided
  if (reason.type === 'other' && reason.customText) {
    return `${label}: ${reason.customText}`;
  }

  return label;
}

/**
 * Build ExportVariant array from display variants with exclusion data
 */
export function buildExportVariants(
  variants: DisplayVariant[],
  excludedIds?: Set<string>,
  reasons?: Map<string, ExclusionReason>
): ExportVariant[] {
  return variants.map((v) => {
    const isExcluded = excludedIds?.has(v.variant_id) ?? false;
    const reason = reasons?.get(v.variant_id);

    return {
      variantId: v.variant_id,
      consequence: v.consequence,
      alleleFrequency: v.alleleFrequency,
      alleleFrequencyPercent: formatPercent(v.alleleFrequency),
      alleleCount: v.alleleCount,
      alleleNumber: v.alleleNumber,
      hgvsC: v.hgvsc,
      hgvsP: v.hgvsp,
      clinvarStatus: v.clinvarStatus,
      isLoF: v.isLoF,
      isClinvarPathogenic: v.isClinvarPathogenic,
      excluded: isExcluded,
      exclusionReason: isExcluded ? formatExclusionReason(reason) : null,
    };
  });
}
```

4. Update buildExportData to pass exclusion data:
```typescript
import type { ExclusionReason } from '@/types';

/**
 * Build complete ExportData object
 */
export function buildExportData(
  result: CarrierFrequencyResult,
  variants: DisplayVariant[],
  filters: FilterConfig,
  excludedIds?: Set<string>,
  reasons?: Map<string, ExclusionReason>
): ExportData {
  return {
    summary: buildExportSummary(result),
    populations: buildExportPopulations(result.populations),
    variants: buildExportVariants(variants, excludedIds, reasons),
    metadata: buildExportMetadata(result.version, filters),
  };
}
```

5. Update callers in StepResults.vue and VariantModal.vue to pass exclusion data (add TODO comment for now - will update in integration):

Add comment at top of export-utils.ts:
```typescript
// Note: Callers (StepResults, VariantModal) need to pass excludedIds and reasons
// from useExclusionState() when calling buildExportVariants/buildExportData
```
  </action>
  <verify>
`bun run typecheck` passes.
`bun run lint` passes.
`grep "lz-string" package.json` shows the dependency.
`grep "excluded: boolean" src/types/export.ts` shows the new field.
  </verify>
  <done>
lz-string installed. ExportVariant type extended with excluded and exclusionReason fields. buildExportVariants accepts exclusion data and formats reasons for display.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create exclusion URL utilities and extend useUrlState</name>
  <files>
    src/utils/exclusion-url.ts
    src/types/url-state.ts
    src/composables/useUrlState.ts
  </files>
  <action>
1. Create `src/utils/exclusion-url.ts`:
```typescript
// URL compression utilities for excluded variant IDs
import LZString from 'lz-string';

/** Maximum compressed exclusion string length for URL safety */
const MAX_EXCLUSION_URL_LENGTH = 1500; // Conservative limit within 2000 char URL

/**
 * Encode excluded variant IDs for URL parameter
 * Uses lz-string compression for efficient encoding
 *
 * @param variantIds - Array of variant IDs to encode
 * @returns Compressed string or null if too long for URL
 */
export function encodeExclusions(variantIds: string[]): string | null {
  if (variantIds.length === 0) return null;

  // Join IDs with comma separator
  const joined = variantIds.join(',');

  // Compress using URL-safe encoding
  const compressed = LZString.compressToEncodedURIComponent(joined);

  // Check if result fits in URL
  if (compressed.length > MAX_EXCLUSION_URL_LENGTH) {
    console.warn(
      `[Exclusion URL] Compressed exclusions (${compressed.length} chars) exceed limit (${MAX_EXCLUSION_URL_LENGTH}). Exclusions will not be included in URL.`
    );
    return null;
  }

  return compressed;
}

/**
 * Decode excluded variant IDs from URL parameter
 *
 * @param compressed - Compressed string from URL
 * @returns Array of variant IDs, empty array if invalid
 */
export function decodeExclusions(compressed: string): string[] {
  if (!compressed) return [];

  try {
    const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
    if (!decompressed) {
      console.warn('[Exclusion URL] Failed to decompress exclusion data');
      return [];
    }
    return decompressed.split(',').filter(Boolean);
  } catch (error) {
    console.warn('[Exclusion URL] Error decoding exclusions:', error);
    return [];
  }
}

/**
 * Check if exclusion list is too large for URL sharing
 *
 * @param variantIds - Array of variant IDs
 * @returns true if exclusions would not fit in URL
 */
export function exclusionsTooLargeForUrl(variantIds: string[]): boolean {
  if (variantIds.length === 0) return false;

  const joined = variantIds.join(',');
  const compressed = LZString.compressToEncodedURIComponent(joined);
  return compressed.length > MAX_EXCLUSION_URL_LENGTH;
}
```

2. Extend `src/types/url-state.ts` to add exclusion parameters:

Add to UrlStateSchema:
```typescript
export const UrlStateSchema = z.object({
  // ... existing fields ...

  /** Compressed excluded variant IDs (lz-string encoded) */
  excl: z.string().optional(),

  /** Warning flag if exclusions were truncated from URL (1=truncated) */
  exclWarn: z.enum(['0', '1']).optional(),
});
```

3. Modify `src/composables/useUrlState.ts` to sync exclusion state:

Add imports:
```typescript
import { useExclusionState } from './useExclusionState';
import { encodeExclusions, decodeExclusions, exclusionsTooLargeForUrl } from '@/utils/exclusion-url';
```

Add exclusion state reference:
```typescript
const { excluded, setExclusions, excludedCount } = useExclusionState();
```

In `restoreFromUrl` function, add exclusion restoration after gene restoration:
```typescript
// Restore exclusions if present in URL
if (urlState.excl) {
  const decodedExclusions = decodeExclusions(urlState.excl);
  if (decodedExclusions.length > 0) {
    setExclusions(decodedExclusions);
  }
}

// Show warning if exclusions were truncated
if (urlState.exclWarn === '1') {
  console.warn('[URL State] Some exclusions were not included in the shared URL due to length limits');
  // Could trigger a toast notification here
}
```

In `updateUrlFromState` function, add exclusion encoding:
```typescript
// Exclusion state
if (excludedCount.value > 0) {
  const encoded = encodeExclusions(excluded.value);
  if (encoded) {
    params.excl = encoded;
    delete params.exclWarn;
  } else {
    // Exclusions too large - set warning flag
    delete params.excl;
    params.exclWarn = '1';
  }
} else {
  delete params.excl;
  delete params.exclWarn;
}
```

Add watch for exclusion state:
```typescript
watch(
  excluded,
  () => updateUrlFromState(),
  { deep: true }
);
```
  </action>
  <verify>
`bun run typecheck` passes.
`bun run lint` passes.
`ls src/utils/exclusion-url.ts` confirms file exists.
`grep "excl:" src/types/url-state.ts` shows URL state field.
Manually test:
1. Exclude some variants
2. Check URL contains `excl=` parameter
3. Copy URL and open in new tab
4. Exclusions should be restored
  </verify>
  <done>
exclusion-url.ts provides lz-string compression utilities. URL state extended with excl and exclWarn fields. useUrlState syncs exclusion state bidirectionally with URL. Large exclusion lists trigger warning instead of truncating.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update export callers with exclusion data</name>
  <files>
    src/components/wizard/StepResults.vue
    src/components/VariantModal.vue
  </files>
  <action>
1. Update StepResults.vue to pass exclusion data to export:

Add to useExclusionState destructuring:
```typescript
const { excludedCount, excluded, reasons } = useExclusionState();
```

Create computed for excluded set:
```typescript
const excludedSet = computed(() => new Set(excluded.value));
```

Update handleExport function:
```typescript
function handleExport(format: 'json' | 'xlsx') {
  if (!props.result) return;

  // Convert filtered variants to display format for export
  // Include ALL variants (including excluded) for complete export
  const allFilteredVariants = filterPathogenicVariantsConfigurable(
    props.variants,
    props.clinvarVariants,
    props.filterConfig,
    props.submissions
  );
  const displayVariants = toDisplayVariants(allFilteredVariants, props.clinvarVariants);

  // Build complete export data with exclusion info
  const exportData = buildExportData(
    props.result,
    displayVariants,
    props.filterConfig,
    excludedSet.value,
    reasons
  );

  if (format === 'json') {
    exportToJson(exportData, props.result.gene);
  } else {
    exportToExcel(exportData, props.result.gene);
  }
}
```

2. Update VariantModal.vue to pass exclusion data to export:

Add to useExclusionState destructuring:
```typescript
const { excludedCount, excluded, reasons, includeAll } = useExclusionState();
```

Create computed for excluded set:
```typescript
const excludedSet = computed(() => new Set(excluded.value));
```

Update handleVariantExport function:
```typescript
function handleVariantExport(format: 'json' | 'xlsx') {
  if (!props.variants.length) return;

  // Import exclusion data utilities
  const exportVariants = buildExportVariants(
    props.variants,
    excludedSet.value,
    reasons
  );

  // ... rest of export logic (unchanged filename generation)

  if (format === 'json') {
    const data = {
      variants: exportVariants,
      populationCode: props.populationCode,
      populationLabel: props.populationLabel,
      exportDate: new Date().toISOString(),
      variantCount: exportVariants.length,
      excludedCount: exportVariants.filter(v => v.excluded).length,
    };
    // ... rest unchanged
  }
  // ... xlsx export unchanged
}
```

Add import for buildExportVariants with new signature if not already updated.
  </action>
  <verify>
`bun run typecheck` passes.
`bun run lint` passes.
Manually test:
1. Exclude some variants
2. Export as JSON from StepResults
3. Check JSON contains excluded: true/false and exclusionReason fields
4. Export as Excel from VariantModal
5. Check Excel has Excluded and ExclusionReason columns
  </verify>
  <done>
StepResults and VariantModal pass exclusion data to export utilities. Exported files include excluded status and reason for all variants (EXCL-06).
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run build` succeeds
4. `bun run dev` - manually test:
   - Exclude variants, export JSON - has excluded/exclusionReason fields
   - Exclude variants, export Excel - has Excluded column
   - Exclude variants, copy URL - contains `excl=` parameter
   - Open copied URL in new tab - exclusions restored
   - Exclude many variants (>50) - may see warning about URL length
</verification>

<success_criteria>
- lz-string installed and working for URL compression
- Export includes excluded variants marked as "excluded" with reason field (EXCL-06)
- URL encodes excluded variant IDs via lz-string compression
- Shared URLs restore exclusion state when opened
- Too-long exclusion lists trigger warning and set exclWarn=1 flag
- All code passes typecheck and lint
</success_criteria>

<output>
After completion, create `.planning/phases/13-variant-exclusion/13-04-SUMMARY.md`
</output>
