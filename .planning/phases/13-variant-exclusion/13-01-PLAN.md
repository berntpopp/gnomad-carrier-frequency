---
phase: 13-variant-exclusion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/exclusion.ts
  - src/types/index.ts
  - src/config/exclusion-reasons.ts
  - src/composables/useExclusionState.ts
  - src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "Exclusion state can be tracked for any variant by ID"
    - "Exclusion reasons are predefined with option for custom text"
    - "Exclusion state resets when gene changes"
    - "Multiple components can access same exclusion state (singleton)"
  artifacts:
    - path: "src/types/exclusion.ts"
      provides: "ExclusionState, ExclusionReason types"
      exports: ["ExclusionState", "ExclusionReason", "PredefinedExclusionReason"]
    - path: "src/config/exclusion-reasons.ts"
      provides: "Predefined exclusion reason options"
      exports: ["EXCLUSION_REASONS"]
    - path: "src/composables/useExclusionState.ts"
      provides: "Singleton composable for exclusion management"
      exports: ["useExclusionState", "UseExclusionStateReturn"]
  key_links:
    - from: "src/composables/useExclusionState.ts"
      to: "src/types/exclusion.ts"
      via: "import types"
      pattern: "import.*ExclusionState"
    - from: "src/composables/useExclusionState.ts"
      to: "src/config/exclusion-reasons.ts"
      via: "import reasons"
      pattern: "import.*EXCLUSION_REASONS"
---

<objective>
Create the foundational infrastructure for variant exclusion: type definitions, predefined exclusion reasons, and a singleton composable that manages exclusion state.

Purpose: Establishes the data model and state management that all other exclusion features depend on. The singleton pattern ensures consistent state across VariantTable, StepResults, and export functionality.

Output:
- `src/types/exclusion.ts` - ExclusionState interface and reason types
- `src/config/exclusion-reasons.ts` - Predefined reason options
- `src/composables/useExclusionState.ts` - Singleton state management composable
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-variant-exclusion/13-CONTEXT.md
@.planning/phases/13-variant-exclusion/13-RESEARCH.md
@src/types/index.ts
@src/composables/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exclusion types and config</name>
  <files>
    src/types/exclusion.ts
    src/types/index.ts
    src/config/exclusion-reasons.ts
  </files>
  <action>
Create `src/types/exclusion.ts` with:

```typescript
// Exclusion types for manual variant exclusion feature

/**
 * Predefined exclusion reasons for quick selection
 */
export type PredefinedExclusionReason =
  | 'likely_benign'
  | 'low_quality'
  | 'population_specific'
  | 'other';

/**
 * Exclusion reason - either predefined or custom text
 */
export interface ExclusionReason {
  type: PredefinedExclusionReason;
  customText?: string; // Only used when type is 'other'
}

/**
 * State for tracking excluded variants
 * Managed by useExclusionState composable
 */
export interface ExclusionState {
  /** Set of excluded variant IDs */
  excluded: Set<string>;
  /** Map of variant ID to exclusion reason */
  reasons: Map<string, ExclusionReason>;
  /** Gene symbol these exclusions apply to (for reset detection) */
  geneSymbol: string | null;
}
```

Create `src/config/exclusion-reasons.ts` with predefined reason options:

```typescript
// Predefined exclusion reason options for UI dropdowns
import type { PredefinedExclusionReason } from '@/types';

export interface ExclusionReasonOption {
  value: PredefinedExclusionReason;
  label: string;
  description: string;
}

/**
 * Predefined exclusion reasons for dropdown selection
 * Per CONTEXT.md: "Likely benign", "Low quality", "Population-specific", "Other"
 */
export const EXCLUSION_REASONS: ExclusionReasonOption[] = [
  {
    value: 'likely_benign',
    label: 'Likely benign',
    description: 'Variant appears benign based on clinical evidence',
  },
  {
    value: 'low_quality',
    label: 'Low quality',
    description: 'Sequencing quality concerns for this variant',
  },
  {
    value: 'population_specific',
    label: 'Population-specific',
    description: 'Variant frequency specific to certain populations',
  },
  {
    value: 'other',
    label: 'Other',
    description: 'Custom reason (specify below)',
  },
];
```

Update `src/types/index.ts` to export exclusion types:
- Add `export * from './exclusion';` with other exports
  </action>
  <verify>
`bun run typecheck` passes with no errors related to exclusion types.
`grep -r "ExclusionState" src/types/` finds the new type definition.
  </verify>
  <done>
ExclusionState, ExclusionReason, PredefinedExclusionReason types are defined and exported. EXCLUSION_REASONS config provides 4 predefined options with labels and descriptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useExclusionState composable</name>
  <files>
    src/composables/useExclusionState.ts
    src/composables/index.ts
  </files>
  <action>
Create `src/composables/useExclusionState.ts` as a singleton composable:

```typescript
// Singleton composable for variant exclusion state management
import { reactive, computed } from 'vue';
import type { ExclusionState, ExclusionReason, PredefinedExclusionReason } from '@/types';

// Module-level singleton state - shared across all useExclusionState() calls
const state = reactive<ExclusionState>({
  excluded: new Set<string>(),
  reasons: new Map<string, ExclusionReason>(),
  geneSymbol: null,
});

export interface UseExclusionStateReturn {
  /** Array of excluded variant IDs (reactive) */
  excluded: ReturnType<typeof computed<string[]>>;
  /** Map of variant ID to reason (reactive) */
  reasons: Map<string, ExclusionReason>;
  /** Count of excluded variants */
  excludedCount: ReturnType<typeof computed<number>>;
  /** Current gene symbol exclusions apply to */
  currentGene: ReturnType<typeof computed<string | null>>;

  // Actions
  /** Exclude a variant with optional reason */
  excludeVariant: (variantId: string, reason?: ExclusionReason) => void;
  /** Include a variant (remove exclusion) */
  includeVariant: (variantId: string) => void;
  /** Toggle variant exclusion state */
  toggleVariant: (variantId: string, reason?: ExclusionReason) => void;
  /** Exclude multiple variants at once */
  excludeAll: (variantIds: string[]) => void;
  /** Include all variants (clear all exclusions) */
  includeAll: () => void;
  /** Check if variant is excluded */
  isExcluded: (variantId: string) => boolean;
  /** Get exclusion reason for variant */
  getReason: (variantId: string) => ExclusionReason | undefined;
  /** Set reason for already-excluded variant */
  setReason: (variantId: string, reason: ExclusionReason) => void;
  /** Reset exclusions when gene changes */
  resetForGene: (geneSymbol: string) => void;
  /** Set exclusions from external source (e.g., URL state) */
  setExclusions: (variantIds: string[], reasons?: Map<string, ExclusionReason>) => void;
}

/**
 * Composable for managing variant exclusion state.
 *
 * Uses singleton pattern - all calls share the same state.
 * Exclusions automatically reset when gene changes.
 *
 * @example
 * ```ts
 * const { excluded, excludeVariant, isExcluded, excludedCount } = useExclusionState();
 *
 * // Exclude a variant
 * excludeVariant('1-12345-A-G', { type: 'likely_benign' });
 *
 * // Check exclusion
 * if (isExcluded('1-12345-A-G')) { ... }
 *
 * // Get excluded IDs for filtering
 * const filteredVariants = allVariants.filter(v => !excluded.value.includes(v.variant_id));
 * ```
 */
export function useExclusionState(): UseExclusionStateReturn {
  // Computed values
  const excluded = computed(() => [...state.excluded]);
  const excludedCount = computed(() => state.excluded.size);
  const currentGene = computed(() => state.geneSymbol);

  // Actions
  function excludeVariant(variantId: string, reason?: ExclusionReason): void {
    state.excluded.add(variantId);
    if (reason) {
      state.reasons.set(variantId, reason);
    }
  }

  function includeVariant(variantId: string): void {
    state.excluded.delete(variantId);
    state.reasons.delete(variantId);
  }

  function toggleVariant(variantId: string, reason?: ExclusionReason): void {
    if (state.excluded.has(variantId)) {
      includeVariant(variantId);
    } else {
      excludeVariant(variantId, reason);
    }
  }

  function excludeAll(variantIds: string[]): void {
    for (const id of variantIds) {
      state.excluded.add(id);
    }
  }

  function includeAll(): void {
    state.excluded.clear();
    state.reasons.clear();
  }

  function isExcluded(variantId: string): boolean {
    return state.excluded.has(variantId);
  }

  function getReason(variantId: string): ExclusionReason | undefined {
    return state.reasons.get(variantId);
  }

  function setReason(variantId: string, reason: ExclusionReason): void {
    if (state.excluded.has(variantId)) {
      state.reasons.set(variantId, reason);
    }
  }

  function resetForGene(geneSymbol: string): void {
    // Only reset if gene actually changed
    if (state.geneSymbol !== geneSymbol) {
      state.excluded.clear();
      state.reasons.clear();
      state.geneSymbol = geneSymbol;
    }
  }

  function setExclusions(variantIds: string[], reasons?: Map<string, ExclusionReason>): void {
    state.excluded.clear();
    state.reasons.clear();
    for (const id of variantIds) {
      state.excluded.add(id);
    }
    if (reasons) {
      for (const [id, reason] of reasons) {
        state.reasons.set(id, reason);
      }
    }
  }

  return {
    excluded,
    reasons: state.reasons,
    excludedCount,
    currentGene,
    excludeVariant,
    includeVariant,
    toggleVariant,
    excludeAll,
    includeAll,
    isExcluded,
    getReason,
    setReason,
    resetForGene,
    setExclusions,
  };
}
```

Update `src/composables/index.ts` to export the new composable:
- Add `export { useExclusionState } from './useExclusionState';`
- Add `export type { UseExclusionStateReturn } from './useExclusionState';`
  </action>
  <verify>
`bun run typecheck` passes with no errors.
`bun run lint` passes with no errors.
`grep "useExclusionState" src/composables/index.ts` shows the export.
  </verify>
  <done>
useExclusionState composable is implemented as a singleton with full API for excluding/including variants, tracking reasons, and resetting on gene change. Exported from composables index.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run build` succeeds
4. Types are exported: `grep "ExclusionState" src/types/index.ts`
5. Composable is exported: `grep "useExclusionState" src/composables/index.ts`
6. Config exists: `ls src/config/exclusion-reasons.ts`
</verification>

<success_criteria>
- ExclusionState, ExclusionReason, PredefinedExclusionReason types defined and exported
- EXCLUSION_REASONS config with 4 predefined options (Likely benign, Low quality, Population-specific, Other)
- useExclusionState composable with singleton pattern for shared state
- Composable supports: exclude, include, toggle, excludeAll, includeAll, isExcluded, getReason, setReason, resetForGene
- All code passes typecheck and lint
</success_criteria>

<output>
After completion, create `.planning/phases/13-variant-exclusion/13-01-SUMMARY.md`
</output>
