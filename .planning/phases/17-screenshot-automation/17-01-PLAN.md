---
phase: 17-screenshot-automation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - scripts/generate-screenshots.ts
  - fixtures/gnomad/cftr-gene-search.json
  - fixtures/gnomad/cftr-gene-details.json
  - fixtures/gnomad/cftr-variants.json
  - fixtures/pinia/default-state.json
  - docs/public/screenshots/.gitkeep
autonomous: true

must_haves:
  truths:
    - "Playwright, sharp, and tsx are installed as dev dependencies"
    - "Running the script starts a dev server, launches Chromium, and shuts down cleanly"
    - "GraphQL requests to gnomAD API are intercepted and served from fixture files"
    - "The clinical disclaimer dialog is auto-dismissed before any captures"
    - "PNG screenshots are converted to WebP format via sharp"
  artifacts:
    - path: "scripts/generate-screenshots.ts"
      provides: "Screenshot generation script with server lifecycle, route interception, and helpers"
      min_lines: 120
    - path: "fixtures/gnomad/cftr-gene-search.json"
      provides: "Mocked GeneSearch response for CFTR"
      contains: "CFTR"
    - path: "fixtures/gnomad/cftr-gene-details.json"
      provides: "Mocked GeneDetails response for CFTR with constraint data"
      contains: "gnomad_constraint"
    - path: "fixtures/gnomad/cftr-variants.json"
      provides: "Mocked GeneVariants response for CFTR with exome/genome/clinvar data"
      contains: "variant_id"
    - path: "fixtures/pinia/default-state.json"
      provides: "Pinia persisted state for template store, app store, history store"
      contains: "templateStore"
  key_links:
    - from: "scripts/generate-screenshots.ts"
      to: "fixtures/gnomad/*.json"
      via: "fs.readFileSync in route handler"
      pattern: "readFileSync.*fixtures"
    - from: "scripts/generate-screenshots.ts"
      to: "sharp"
      via: "PNG buffer to WebP file conversion"
      pattern: "sharp.*webp"
    - from: "scripts/generate-screenshots.ts"
      to: "http://localhost:5173"
      via: "page.goto after dev server ready detection"
      pattern: "localhost:5173"
---

<objective>
Install Playwright, sharp, and tsx as dev dependencies. Create realistic API fixture files from gnomAD response shapes for CFTR. Build the screenshot generation script scaffold with: dev server lifecycle management (spawn npm run dev, detect ready, kill on exit), GraphQL route interception matching by operationName (GeneSearch, GeneDetails, GeneVariants, ClinVarSubmissions), localStorage injection for Pinia state, clinical disclaimer auto-dismissal, WebP conversion helper, and animation wait helper. The script should be runnable but will contain zero screenshot capture calls (those come in Plan 03).

Purpose: This is the foundation that all screenshot captures depend on. Without mocked data and server management, no screenshots can be reliably generated.
Output: Runnable script that starts server, opens browser, dismisses disclaimer, and exits cleanly. Fixture files committed. Dependencies installed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-screenshot-automation/17-CONTEXT.md
@.planning/phases/17-screenshot-automation/17-RESEARCH.md

Key codebase references:
@src/api/queries/gene-search.ts (GeneSearch and GeneDetails query shapes)
@src/api/queries/gene-variants.ts (GeneVariants query shape)
@src/api/queries/clinvar-submissions.ts (ClinVarSubmissions query shape)
@src/api/client.ts (endpoint: https://gnomad.broadinstitute.org/api)
@src/components/DisclaimerBanner.vue (disclaimer dialog structure - v-dialog with "I Understand" button)
@src/config/gnomad.json (API endpoint and dataset config)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create fixture files</name>
  <files>
    package.json
    fixtures/gnomad/cftr-gene-search.json
    fixtures/gnomad/cftr-gene-details.json
    fixtures/gnomad/cftr-variants.json
    fixtures/pinia/default-state.json
    docs/public/screenshots/.gitkeep
  </files>
  <action>
    1. Install dev dependencies:
       ```
       npm install --save-dev playwright sharp tsx
       npx playwright install chromium
       ```
       Note: Only install chromium browser, not all browsers.

    2. Create `fixtures/gnomad/cftr-gene-search.json` with a realistic GeneSearch response:
       ```json
       {
         "data": {
           "gene_search": [
             { "ensembl_id": "ENSG00000001626", "symbol": "CFTR" }
           ]
         }
       }
       ```

    3. Create `fixtures/gnomad/cftr-gene-details.json` with GeneDetails response including constraint:
       ```json
       {
         "data": {
           "gene": {
             "gene_id": "ENSG00000001626",
             "symbol": "CFTR",
             "gnomad_constraint": {
               "exp_lof": 63.8,
               "obs_lof": 33,
               "oe_lof": 0.52,
               "oe_lof_lower": 0.38,
               "oe_lof_upper": 0.71,
               "pLI": 0.0091,
               "lof_z": 2.6,
               "flags": []
             }
           }
         }
       }
       ```

    4. Create `fixtures/gnomad/cftr-variants.json` with a realistic GeneVariants response for CFTR.
       Include at least 8-10 variants covering:
       - 3-4 LoF HC variants (lof: "HC") with realistic CFTR allele frequencies
       - 3-4 ClinVar pathogenic variants with varying gold stars (1-4)
       - 1-2 missense variants
       - Each variant needs exome AND genome data with population breakdowns
       - Population IDs: "afr", "amr", "asj", "eas", "fin", "nfe", "sas", "oth" (for gnomAD v4 use "remaining" instead of "oth")
       - Use realistic CFTR variant IDs (e.g., "7-117559590-ATCT-A" for deltaF508)
       - Include clinvar_variants array with matching variant_ids, clinical_significance ("Pathogenic", "Likely pathogenic"), gold_stars (0-4), review_status
       The fixture must produce a carrier frequency around 1:25 for global (realistic for CFTR) with Ashkenazi Jewish population showing higher frequency (~1:17). Make the allele counts (ac/an) realistic.
       IMPORTANT: The response structure must match the exact GraphQL query shape in src/api/queries/gene-variants.ts including the clinvar_variants array nested under gene.

    5. Create `fixtures/pinia/default-state.json` with Pinia persisted state entries:
       ```json
       {
         "templateStore": {
           "language": "de",
           "genderStyle": "*",
           "enabledSections": ["gene_introduction", "inheritance_pattern", "carrier_frequency", "recurrence_risk", "recommendations"]
         },
         "appStore": {
           "disclaimerAcknowledged": false,
           "theme": "light"
         },
         "historyStore": {
           "entries": [
             {
               "id": "demo-cftr-1",
               "gene": { "symbol": "CFTR", "ensembl_id": "ENSG00000001626" },
               "gnomadVersion": "4.1.0",
               "indexPatientStatus": "heterozygous",
               "frequencySource": "gnomad",
               "results": {
                 "globalCarrierFrequency": 0.04,
                 "populations": []
               },
               "timestamp": 1707400000000
             }
           ],
           "settings": { "maxEntries": 50 }
         }
       }
       ```
       Check the actual Pinia store key names used by pinia-plugin-persistedstate in the app stores. The localStorage keys should match what the stores expect.

    6. Create `docs/public/screenshots/.gitkeep` (empty file) to ensure the output directory exists in git.

    7. Add `.gitkeep` entry: Also add `docs/public/screenshots/*.webp` to `.gitignore` so generated screenshots are not committed (they are build artifacts). BUT keep the `.gitkeep`.
  </action>
  <verify>
    - `npm ls playwright sharp tsx` shows all three installed
    - `npx playwright --version` outputs a version number
    - `ls fixtures/gnomad/` shows 3 JSON files
    - `ls fixtures/pinia/` shows 1 JSON file
    - `node -e "const f = require('./fixtures/gnomad/cftr-variants.json'); console.log(f.data.gene.variants.length)"` outputs a number >= 8
    - `ls docs/public/screenshots/.gitkeep` exists
  </verify>
  <done>
    Playwright, sharp, and tsx are installed. Four fixture files contain realistic CFTR data matching gnomAD GraphQL response shapes. Output directory exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create screenshot script scaffold with server lifecycle and route interception</name>
  <files>scripts/generate-screenshots.ts</files>
  <action>
    Create `scripts/generate-screenshots.ts` as a standalone TypeScript script. Structure it with these sections:

    **1. Imports and types:**
    ```typescript
    import { chromium, type Page, type BrowserContext } from 'playwright';
    import sharp from 'sharp';
    import { spawn, type ChildProcess } from 'child_process';
    import { readFileSync, mkdirSync } from 'fs';
    import { resolve } from 'path';
    ```

    **2. Configuration constants:**
    ```typescript
    const BASE_URL = 'http://localhost:5173/gnomad-carrier-frequency/';
    const OUTPUT_DIR = resolve(__dirname, '../docs/public/screenshots');
    const FIXTURES_DIR = resolve(__dirname, '../fixtures');
    const VIEWPORT_DESKTOP = { width: 1200, height: 800 };
    const VIEWPORT_MOBILE = { width: 375, height: 812 };
    const WEBP_QUALITY = 80;
    ```
    IMPORTANT: The app uses base path `/gnomad-carrier-frequency/` in production but Vite dev server serves at root `/`. Check vite.config.ts to confirm — in dev mode the base is likely `/` or `/gnomad-carrier-frequency/`. Use the correct URL.

    **3. Fixture loading helper:**
    Load fixture JSON files from disk. Create a function `loadFixture(path: string)` that reads and parses JSON.

    **4. Dev server management:**
    - `startDevServer()`: Spawn `npm run dev` as child process, monitor stdout for "Local:" or "ready in" to detect server ready. Return the ChildProcess. Set a 30-second timeout — if server doesn't start, throw error.
    - `stopDevServer(server: ChildProcess)`: Send SIGTERM, wait briefly, then SIGKILL if still alive.
    - Handle process.on('exit') and process.on('SIGINT') to ensure server cleanup.

    **5. GraphQL route interception:**
    Create `setupRouteInterception(page: Page)` that calls `page.route()` matching `**/api` (the gnomAD GraphQL endpoint at `https://gnomad.broadinstitute.org/api`).
    - Parse `postDataJSON()` to get the operationName
    - Match operation names to fixture files:
      - "GeneSearch" -> cftr-gene-search.json
      - "GeneDetails" -> cftr-gene-details.json
      - "GeneVariants" -> cftr-variants.json
      - "ClinVarSubmissions" -> create an inline empty response `{ "data": {} }` (not needed for screenshots but prevents errors)
    - For any unmatched operationName, log a warning and return an empty data response
    - Use `route.fulfill()` with status 200 and correct content-type

    **6. Pinia localStorage injection:**
    Create `injectPiniaState(context: BrowserContext)` or do it via storageState when creating context. Load `fixtures/pinia/default-state.json`, set each key as a localStorage entry for the app's origin. The disclaimerAcknowledged should be FALSE initially (script will dismiss it interactively for a cleaner flow).

    Actually, reconsider: set `appStore.disclaimerAcknowledged = true` in the localStorage injection so the disclaimer doesn't appear at all. This is cleaner than dismissing it via click. The CONTEXT.md says "auto-dismissed" which can mean either approach. Pre-seeding localStorage is more reliable.

    Wait — but we need to be able to capture the disclaimer if needed in future. For now, set `disclaimerAcknowledged: true` in the injected state so screenshots are clean.

    **7. WebP capture helper:**
    ```typescript
    async function capture(page: Page, name: string): Promise<void> {
      console.log(`  Capturing ${name}...`);
      const png = await page.screenshot({ type: 'png', fullPage: false });
      await sharp(png).webp({ quality: WEBP_QUALITY }).toFile(resolve(OUTPUT_DIR, `${name}.webp`));
      console.log(`  -> ${name}.webp`);
    }
    ```

    **8. Animation wait helper:**
    ```typescript
    async function waitForAnimations(page: Page): Promise<void> {
      // Wait for any in-flight network requests
      await page.waitForLoadState('networkidle').catch(() => {});
      // Wait for CSS animations/transitions to complete
      await page.evaluate(async () => {
        const allElements = document.querySelectorAll('*');
        const animations = Array.from(allElements).flatMap(el =>
          el.getAnimations({ subtree: false })
        );
        if (animations.length > 0) {
          await Promise.all(animations.map(a => a.finished));
        }
      });
      // Buffer for any remaining Vuetify transitions
      await page.waitForTimeout(500);
    }
    ```

    **9. Main function scaffold:**
    ```typescript
    async function main() {
      console.log('Screenshot Generation Script');
      console.log('============================\n');

      mkdirSync(OUTPUT_DIR, { recursive: true });

      // Start dev server
      const server = await startDevServer();

      try {
        // Launch browser
        const browser = await chromium.launch({ headless: true });
        const context = await browser.newContext({
          viewport: VIEWPORT_DESKTOP,
          colorScheme: 'light',
          // storageState with Pinia state injection
        });
        const page = await context.newPage();

        // Set up route interception
        await setupRouteInterception(page);

        // Navigate to app
        await page.goto(BASE_URL);
        await waitForAnimations(page);

        console.log('Browser ready. App loaded.\n');

        // === SCREENSHOT CAPTURES GO HERE (Plan 03) ===

        console.log('\nAll screenshots captured successfully!');
        console.log(`Output: ${OUTPUT_DIR}/`);

        await browser.close();
      } finally {
        stopDevServer(server);
      }
    }

    main().catch((err) => {
      console.error('\nScreenshot generation FAILED:', err.message);
      process.exit(1);
    });
    ```

    **Key implementation notes:**
    - Use `readFileSync` for fixtures (synchronous is fine for a build script)
    - All console output should be informative (which screenshot is being captured, success/failure)
    - Fail fast: any error in capture should propagate and stop the script
    - Do NOT use `animations: 'disabled'` in page.screenshot() — we want to capture the app in its natural rendered state, just after animations complete
    - The script must work from the project root directory (resolve paths relative to __dirname)
  </action>
  <verify>
    - `npx tsx scripts/generate-screenshots.ts` runs, starts dev server, opens browser, prints "Browser ready. App loaded.", and exits cleanly (since no captures are defined yet)
    - Dev server process is killed after script exits
    - No orphaned Node.js processes remain
  </verify>
  <done>
    Script runs end-to-end: starts dev server, launches headless Chromium, intercepts GraphQL with fixture data, navigates to app, and shuts down cleanly. Ready for screenshot capture functions to be added.
  </done>
</task>

</tasks>

<verification>
- `npm ls playwright sharp tsx` confirms all dependencies
- `npx playwright --version` works
- `npx tsx scripts/generate-screenshots.ts` completes without error
- Fixture files are valid JSON with correct structure
- No orphaned processes after script exits (check with `ps aux | grep node`)
</verification>

<success_criteria>
- SHOT-01 partially satisfied (Playwright installed, script exists but no captures yet)
- SHOT-17 satisfied (disclaimer auto-dismissed via localStorage injection)
- Fixture files provide realistic CFTR data for all screenshot states
- Script scaffold is ready for screenshot capture functions
</success_criteria>

<output>
After completion, create `.planning/phases/17-screenshot-automation/17-01-SUMMARY.md`
</output>
