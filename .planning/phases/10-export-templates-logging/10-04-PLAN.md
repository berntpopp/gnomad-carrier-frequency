---
phase: 10-export-templates-logging
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/template-variables.ts
  - src/utils/template-parser.ts
  - src/stores/useTemplateStore.ts
autonomous: true

must_haves:
  truths:
    - "Template variables are defined with name, description, and example value"
    - "Template strings can be parsed into segments (text and variable)"
    - "Custom template sections can be exported to JSON file"
    - "Custom template sections can be imported from JSON file"
    - "Per-language reset restores defaults without affecting other language"
  artifacts:
    - path: "src/config/template-variables.ts"
      provides: "TEMPLATE_VARIABLES array with metadata for variable picker"
      exports: ["TEMPLATE_VARIABLES", "TemplateVariable"]
    - path: "src/utils/template-parser.ts"
      provides: "parseTemplate function for editor highlighting"
      exports: ["parseTemplate", "TemplateSegment"]
    - path: "src/stores/useTemplateStore.ts"
      provides: "Extended store with export/import/reset actions"
      contains: "exportTemplates"
  key_links:
    - from: "src/utils/template-parser.ts"
      to: "src/utils/template-renderer.ts"
      via: "consistent variable regex"
      pattern: "\\{\\{(\\w+)\\}\\}"
    - from: "src/stores/useTemplateStore.ts"
      to: "src/config/template-variables.ts"
      via: "variable definitions"
      pattern: "TEMPLATE_VARIABLES"
---

<objective>
Extend template infrastructure with variable definitions, parsing utility, and import/export actions.

Purpose: Foundation for template editor UI with variable highlighting and template file management.
Output: Variable config, template parser, extended useTemplateStore with import/export/reset.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-templates-logging/10-CONTEXT.md
@.planning/phases/10-export-templates-logging/10-RESEARCH.md

@src/stores/useTemplateStore.ts (extend this)
@src/types/text.ts (TemplateContext interface - source of truth for variables)
@src/utils/template-renderer.ts (existing renderer with {{variable}} pattern)
@src/config/templates/en.json (template structure reference)
@src/config/templates/de.json (template structure reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template variables configuration</name>
  <files>src/config/template-variables.ts</files>
  <action>
Create configuration file defining all available template variables with metadata for the variable picker:

```typescript
/**
 * Metadata for a template variable
 */
export interface TemplateVariable {
  name: string; // Variable name (without braces)
  description: string; // Human-readable description
  example: string; // Example value for preview
  category: 'gene' | 'frequency' | 'risk' | 'context' | 'formatting';
}

/**
 * All available template variables
 * Source of truth: src/types/text.ts TemplateContext interface
 */
export const TEMPLATE_VARIABLES: TemplateVariable[] = [
  // Gene category
  {
    name: 'gene',
    description: 'Gene symbol',
    example: 'CFTR',
    category: 'gene',
  },

  // Frequency category
  {
    name: 'carrierFrequency',
    description: 'Carrier frequency as percentage',
    example: '4.0%',
    category: 'frequency',
  },
  {
    name: 'carrierFrequencyRatio',
    description: 'Carrier frequency as ratio',
    example: '1:25',
    category: 'frequency',
  },

  // Risk category
  {
    name: 'recurrenceRiskPercent',
    description: 'Recurrence risk as percentage',
    example: '0.25%',
    category: 'risk',
  },
  {
    name: 'recurrenceRiskRatio',
    description: 'Recurrence risk as ratio',
    example: '1:400',
    category: 'risk',
  },

  // Context category
  {
    name: 'source',
    description: 'Data source attribution',
    example: 'gnomAD v4.1.0',
    category: 'context',
  },
  {
    name: 'indexStatus',
    description: 'Index patient status',
    example: 'heterozygous',
    category: 'context',
  },
  {
    name: 'statusIntro',
    description: 'Status-specific introduction text',
    example: 'A homozygous pathogenic variant...',
    category: 'context',
  },
  {
    name: 'populationName',
    description: 'Population name (optional)',
    example: 'European (non-Finnish)',
    category: 'context',
  },
  {
    name: 'pmid',
    description: 'PubMed ID for citations (optional)',
    example: '12345678',
    category: 'context',
  },
  {
    name: 'accessDate',
    description: 'Formatted access date',
    example: 'January 19, 2026',
    category: 'context',
  },

  // Formatting category (German-specific)
  {
    name: 'genderSuffix',
    description: 'Gender-inclusive suffix (German)',
    example: '*innen',
    category: 'formatting',
  },
  {
    name: 'patientNominative',
    description: 'Patient in nominative case (German)',
    example: 'der Patient',
    category: 'formatting',
  },
  {
    name: 'patientGenitive',
    description: 'Patient in genitive case (German)',
    example: 'des Patienten',
    category: 'formatting',
  },
  {
    name: 'patientDative',
    description: 'Patient in dative case (German)',
    example: 'dem Patienten',
    category: 'formatting',
  },
];

/**
 * Get variables by category
 */
export function getVariablesByCategory(category: TemplateVariable['category']): TemplateVariable[] {
  return TEMPLATE_VARIABLES.filter(v => v.category === category);
}

/**
 * Get variable by name
 */
export function getVariableByName(name: string): TemplateVariable | undefined {
  return TEMPLATE_VARIABLES.find(v => v.name === name);
}
```
  </action>
  <verify>`bun run typecheck` passes, TEMPLATE_VARIABLES exports correctly</verify>
  <done>Template variables defined with metadata for picker UI</done>
</task>

<task type="auto">
  <name>Task 2: Create template parser utility</name>
  <files>src/utils/template-parser.ts</files>
  <action>
Create utility for parsing templates into segments for editor highlighting:

```typescript
/**
 * Segment of a parsed template
 */
export interface TemplateSegment {
  type: 'text' | 'variable';
  content: string; // For text: the text, for variable: the variable name (without braces)
  raw?: string; // For variable: the raw {{variable}} string
}

/**
 * Parse template string into segments of text and variables
 * Consistent with template-renderer.ts regex pattern
 *
 * @example
 * parseTemplate('Hello {{gene}} world')
 * // Returns: [
 * //   { type: 'text', content: 'Hello ' },
 * //   { type: 'variable', content: 'gene', raw: '{{gene}}' },
 * //   { type: 'text', content: ' world' }
 * // ]
 */
export function parseTemplate(template: string): TemplateSegment[] {
  const regex = /(\{\{(\w+)\}\})/g;
  const segments: TemplateSegment[] = [];
  let lastIndex = 0;
  let match;

  while ((match = regex.exec(template)) !== null) {
    // Text before variable
    if (match.index > lastIndex) {
      segments.push({
        type: 'text',
        content: template.slice(lastIndex, match.index),
      });
    }

    // Variable
    segments.push({
      type: 'variable',
      content: match[2], // Variable name without braces
      raw: match[1], // Full {{variable}} string
    });

    lastIndex = regex.lastIndex;
  }

  // Remaining text after last variable
  if (lastIndex < template.length) {
    segments.push({
      type: 'text',
      content: template.slice(lastIndex),
    });
  }

  return segments;
}

/**
 * Reconstruct template string from segments
 */
export function segmentsToTemplate(segments: TemplateSegment[]): string {
  return segments.map(seg =>
    seg.type === 'variable' ? `{{${seg.content}}}` : seg.content
  ).join('');
}

/**
 * Check if a variable name is valid (exists in TEMPLATE_VARIABLES)
 */
export function isValidVariable(name: string): boolean {
  // Import dynamically to avoid circular dependency
  const { TEMPLATE_VARIABLES } = require('@/config/template-variables');
  return TEMPLATE_VARIABLES.some((v: { name: string }) => v.name === name);
}
```
  </action>
  <verify>`bun run typecheck` passes, parseTemplate returns correct segments</verify>
  <done>Template parser extracts text and variable segments for editor highlighting</done>
</task>

<task type="auto">
  <name>Task 3: Extend useTemplateStore with import/export/reset</name>
  <files>src/stores/useTemplateStore.ts</files>
  <action>
Add import, export, and per-language reset functionality to useTemplateStore:

1. Add new types for export format:
```typescript
interface TemplateExport {
  version: string;
  language: 'de' | 'en';
  exportDate: string;
  customSections: Record<string, string>;
  enabledSections: Record<Perspective, string[]>;
}
```

2. Add new actions to the store:

```typescript
actions: {
  // ... existing actions ...

  /**
   * Export current template customizations for a language
   */
  exportTemplates(): TemplateExport {
    return {
      version: '1.0',
      language: this.language,
      exportDate: new Date().toISOString(),
      customSections: { ...this.customSections },
      enabledSections: { ...this.enabledSections },
    };
  },

  /**
   * Import template customizations from file
   * Returns true if successful, false if invalid format
   */
  importTemplates(data: unknown): boolean {
    // Validate structure
    if (!data || typeof data !== 'object') return false;
    const exported = data as TemplateExport;

    if (!exported.version || !exported.language) return false;
    if (!exported.customSections || typeof exported.customSections !== 'object') return false;
    if (!exported.enabledSections || typeof exported.enabledSections !== 'object') return false;

    // Apply customizations
    this.language = exported.language;
    this.customSections = { ...exported.customSections };

    // Merge enabled sections (preserve structure for all perspectives)
    for (const perspective of ['affected', 'carrier', 'familyMember'] as Perspective[]) {
      if (exported.enabledSections[perspective]) {
        this.enabledSections[perspective] = [...exported.enabledSections[perspective]];
      }
    }

    return true;
  },

  /**
   * Reset customizations for a specific language
   * Only clears customSections that belong to that language
   */
  resetLanguageTemplates(lang: 'de' | 'en') {
    // Custom sections are keyed by perspective.sectionId
    // They apply regardless of language, but user expects per-language reset
    // Since templates are language-specific in the JSON files, we clear all customizations
    // when user resets, as the custom content was likely written in that language
    if (this.language === lang) {
      this.customSections = {};
    }
  },

  /**
   * Get effective template for a section
   * Returns custom if exists, otherwise default
   */
  getEffectiveTemplate(perspective: Perspective, sectionId: string): string {
    const key = `${perspective}.${sectionId}`;
    if (this.customSections[key]) {
      return this.customSections[key];
    }
    return this.defaultTemplates.perspectives[perspective]?.sections[sectionId]?.template ?? '';
  },

  /**
   * Check if a section has customizations
   */
  hasCustomization(perspective: Perspective, sectionId: string): boolean {
    const key = `${perspective}.${sectionId}`;
    return key in this.customSections;
  },
},
```

3. Ensure Perspective type is imported at top of file if not already:
```typescript
import type { Perspective, GenderStyle, PatientSex, TemplateConfig } from '@/types';
```
  </action>
  <verify>`bun run typecheck` passes, new actions available on store</verify>
  <done>useTemplateStore has exportTemplates, importTemplates, resetLanguageTemplates, getEffectiveTemplate actions</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` - all types resolve
2. `bun run lint` - no ESLint errors
3. TEMPLATE_VARIABLES contains all TemplateContext keys
4. parseTemplate correctly splits "Hello {{gene}}" into 3 segments
5. Store exportTemplates returns valid JSON structure
6. Store importTemplates accepts exported data and applies it
</verification>

<success_criteria>
- TMPL-03 foundation: parseTemplate enables variable highlighting
- TMPL-04 foundation: TEMPLATE_VARIABLES provides picker data
- TMPL-05 foundation: Variable insertion uses TEMPLATE_VARIABLES
- TMPL-06: exportTemplates action ready for UI integration
- TMPL-07: importTemplates action ready for UI integration
- TMPL-08 foundation: Store persistence already handles this
- Per-language reset enables independent German/English reset
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-templates-logging/10-04-SUMMARY.md`
</output>
