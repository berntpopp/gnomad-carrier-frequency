---
phase: 10-export-templates-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/log.ts
  - src/types/index.ts
  - src/stores/useLogStore.ts
  - src/composables/useLogger.ts
  - src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "Log entries can be created with level, category, message, and optional details"
    - "Log store persists entries to localStorage with configurable max size"
    - "Ring buffer pattern automatically prunes oldest entries when limit reached"
    - "Log statistics (count, dropped, memory estimate) are computed"
  artifacts:
    - path: "src/types/log.ts"
      provides: "LogLevel, LogEntry, LogSettings, LogStats types"
      exports: ["LogLevel", "LogEntry", "LogSettings", "LogStats"]
    - path: "src/stores/useLogStore.ts"
      provides: "Pinia store with ring buffer log management"
      exports: ["useLogStore"]
    - path: "src/composables/useLogger.ts"
      provides: "Composable wrapping log store with convenience methods"
      exports: ["useLogger"]
  key_links:
    - from: "src/composables/useLogger.ts"
      to: "src/stores/useLogStore.ts"
      via: "pinia store import"
      pattern: "useLogStore\\(\\)"
    - from: "src/stores/useLogStore.ts"
      to: "src/types/log.ts"
      via: "type imports"
      pattern: "import.*from.*types/log"
---

<objective>
Create logging infrastructure with Pinia store, ring buffer pattern, and convenience composable.

Purpose: Foundation for application-wide event logging (API calls, calculations, errors) with memory-safe storage and persistence.
Output: Log types, useLogStore with persistence, useLogger composable for easy logging throughout app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-templates-logging/10-CONTEXT.md
@.planning/phases/10-export-templates-logging/10-RESEARCH.md

@src/stores/useAppStore.ts (persistence pattern reference)
@src/stores/useFilterStore.ts (state/actions pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create log type definitions</name>
  <files>src/types/log.ts, src/types/index.ts</files>
  <action>
Create src/types/log.ts with:

```typescript
export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

export interface LogEntry {
  id: number;
  timestamp: number; // Date.now()
  level: LogLevel;
  category: string; // 'api', 'calculation', 'error', 'user', etc.
  message: string;
  details?: unknown; // Optional structured data
}

export interface LogSettings {
  maxEntries: number; // Default 500
  autoClearOnStart: boolean;
  defaultFilterLevel: LogLevel;
  enabledCategories: string[];
}

export interface LogStats {
  totalCount: number;
  droppedCount: number;
  memoryEstimate: string; // "12.5 KB"
  byLevel: Record<LogLevel, number>;
}
```

Export from src/types/index.ts:
```typescript
export type { LogLevel, LogEntry, LogSettings, LogStats } from './log';
```
  </action>
  <verify>TypeScript compilation succeeds: `bun run typecheck`</verify>
  <done>Log types exported and importable from @/types</done>
</task>

<task type="auto">
  <name>Task 2: Create useLogStore with ring buffer</name>
  <files>src/stores/useLogStore.ts</files>
  <action>
Create Pinia store following existing patterns (useAppStore, useFilterStore):

```typescript
import { defineStore } from 'pinia';
import type { LogLevel, LogEntry, LogSettings, LogStats } from '@/types';

interface LogStoreState {
  entries: LogEntry[];
  nextId: number;
  droppedCount: number;
  settings: LogSettings;
}

export const useLogStore = defineStore('logs', {
  state: (): LogStoreState => ({
    entries: [],
    nextId: 1,
    droppedCount: 0,
    settings: {
      maxEntries: 500,
      autoClearOnStart: false,
      defaultFilterLevel: 'INFO',
      enabledCategories: ['api', 'calculation', 'error', 'user'],
    },
  }),

  getters: {
    stats: (state): LogStats => {
      const bytes = JSON.stringify(state.entries).length;
      const memoryEstimate = bytes < 1024
        ? `${bytes} B`
        : bytes < 1024 * 1024
          ? `${(bytes / 1024).toFixed(1)} KB`
          : `${(bytes / (1024 * 1024)).toFixed(1)} MB`;

      const byLevel: Record<LogLevel, number> = { DEBUG: 0, INFO: 0, WARN: 0, ERROR: 0 };
      state.entries.forEach(e => byLevel[e.level]++);

      return {
        totalCount: state.entries.length,
        droppedCount: state.droppedCount,
        memoryEstimate,
        byLevel,
      };
    },
  },

  actions: {
    log(level: LogLevel, category: string, message: string, details?: unknown) {
      const entry: LogEntry = {
        id: this.nextId++,
        timestamp: Date.now(),
        level,
        category,
        message,
        details,
      };

      this.entries.push(entry);

      // Ring buffer: remove oldest when exceeding max
      while (this.entries.length > this.settings.maxEntries) {
        this.entries.shift();
        this.droppedCount++;
      }
    },

    clear() {
      this.entries = [];
      // Note: droppedCount preserved for statistics
    },

    clearAll() {
      this.entries = [];
      this.droppedCount = 0;
      this.nextId = 1;
    },

    updateSettings(settings: Partial<LogSettings>) {
      Object.assign(this.settings, settings);
      // Enforce new max immediately
      while (this.entries.length > this.settings.maxEntries) {
        this.entries.shift();
        this.droppedCount++;
      }
    },
  },

  persist: {
    key: 'carrier-freq-logs',
    storage: localStorage,
  },
});
```

Key behaviors:
- Ring buffer prunes oldest entries when maxEntries exceeded
- droppedCount tracks total pruned for statistics
- updateSettings immediately enforces new maxEntries
- clear() preserves droppedCount, clearAll() resets everything
  </action>
  <verify>`bun run typecheck` passes, store can be instantiated in Vue devtools</verify>
  <done>useLogStore exports from stores directory with ring buffer and persistence</done>
</task>

<task type="auto">
  <name>Task 3: Create useLogger composable</name>
  <files>src/composables/useLogger.ts, src/composables/index.ts</files>
  <action>
Create convenience composable wrapping the store:

```typescript
import { useLogStore } from '@/stores/useLogStore';
import type { LogLevel } from '@/types';

export function useLogger(category: string = 'app') {
  const store = useLogStore();

  function log(level: LogLevel, message: string, details?: unknown) {
    store.log(level, category, message, details);
  }

  return {
    // Convenience level methods
    debug: (message: string, details?: unknown) => log('DEBUG', message, details),
    info: (message: string, details?: unknown) => log('INFO', message, details),
    warn: (message: string, details?: unknown) => log('WARN', message, details),
    error: (message: string, details?: unknown) => log('ERROR', message, details),

    // Direct access to store for advanced use
    store,
  };
}
```

Update src/composables/index.ts to export:
```typescript
export { useLogger } from './useLogger';
```

Usage pattern for other composables/components:
```typescript
const logger = useLogger('api');
logger.info('Fetching gene variants', { gene: 'CFTR' });
logger.error('API request failed', { error: err.message });
```
  </action>
  <verify>`bun run typecheck` passes, useLogger importable from @/composables</verify>
  <done>useLogger composable provides debug/info/warn/error convenience methods</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` - all type definitions resolve
2. `bun run lint` - no ESLint errors
3. Types importable: `import type { LogLevel, LogEntry } from '@/types'`
4. Store instantiates: `const logStore = useLogStore()` in component
5. Composable works: `const logger = useLogger('test'); logger.info('test')`
</verification>

<success_criteria>
- LOG-01 foundation: Types and store ready for logging key events
- LOG-07 foundation: Stats getter provides count, dropped, memory
- LOG-08 foundation: maxEntries configurable in settings object
- Ring buffer pattern prevents unbounded memory growth
- Persistence to localStorage via pinia-plugin-persistedstate
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-templates-logging/10-01-SUMMARY.md`
</output>
