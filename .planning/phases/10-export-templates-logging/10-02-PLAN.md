---
phase: 10-export-templates-logging
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bun.lockb
  - src/types/export.ts
  - src/types/index.ts
  - src/utils/export-utils.ts
  - src/composables/useExport.ts
  - src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "Excel files can be generated with multiple sheets (Summary, Populations, Variants, Metadata)"
    - "JSON export includes properly formatted calculation results"
    - "Export filenames follow gene-date pattern with sanitization"
    - "Blob download works in browser without external dependencies"
  artifacts:
    - path: "src/types/export.ts"
      provides: "ExportData, ExportMetadata, ExportSummary types"
      exports: ["ExportData", "ExportMetadata", "ExportSummary"]
    - path: "src/utils/export-utils.ts"
      provides: "Pure functions for data formatting and filename generation"
      exports: ["sanitizeFilename", "generateFilename", "formatExportDate"]
    - path: "src/composables/useExport.ts"
      provides: "Composable with exportToJson and exportToExcel methods"
      exports: ["useExport"]
  key_links:
    - from: "src/composables/useExport.ts"
      to: "xlsx"
      via: "SheetJS import"
      pattern: "import.*XLSX.*from.*xlsx"
    - from: "src/composables/useExport.ts"
      to: "src/types/export.ts"
      via: "type imports"
      pattern: "import.*ExportData.*from"
---

<objective>
Create export infrastructure with SheetJS for Excel generation and pure utility functions.

Purpose: Foundation for exporting calculation results as JSON or Excel files with proper metadata.
Output: Export types, utility functions, useExport composable ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-export-templates-logging/10-CONTEXT.md
@.planning/phases/10-export-templates-logging/10-RESEARCH.md

@src/types/frequency.ts (CarrierFrequencyResult, PopulationFrequency types)
@src/types/filter.ts (FilterConfig type)
@src/types/display.ts (DisplayVariant type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install xlsx and create export types</name>
  <files>package.json, bun.lockb, src/types/export.ts, src/types/index.ts</files>
  <action>
Install SheetJS xlsx library:
```bash
bun add xlsx
```

Create src/types/export.ts:

```typescript
import type { PopulationFrequency, FilterConfig, DisplayVariant } from '@/types';
import type { GnomadVersion } from '@/config';

/**
 * Metadata included in all exports
 */
export interface ExportMetadata {
  exportDate: string; // ISO format
  gnomadVersion: GnomadVersion;
  gnomadDisplayName: string;
  filtersApplied: FilterConfig;
  appVersion: string;
}

/**
 * Summary sheet data (single row)
 */
export interface ExportSummary {
  gene: string;
  globalCarrierFrequency: number | null;
  globalCarrierFrequencyPercent: string;
  globalCarrierFrequencyRatio: string;
  globalAlleleCount: number;
  globalAlleleNumber: number;
  qualifyingVariantCount: number;
  minFrequency: number | null;
  maxFrequency: number | null;
  hasFounderEffect: boolean;
}

/**
 * Population row for export
 */
export interface ExportPopulation {
  code: string;
  label: string;
  carrierFrequency: number | null;
  carrierFrequencyPercent: string;
  carrierFrequencyRatio: string;
  alleleCount: number;
  alleleNumber: number;
  isFounderEffect: boolean;
}

/**
 * Variant row for export
 */
export interface ExportVariant {
  variantId: string;
  consequence: string;
  alleleFrequency: number;
  alleleFrequencyPercent: string;
  alleleCount: number;
  alleleNumber: number;
  hgvsC: string | null;
  hgvsP: string | null;
  clinvarStatus: string;
  isLoF: boolean;
  isClinvarPathogenic: boolean;
}

/**
 * Complete export data structure
 */
export interface ExportData {
  summary: ExportSummary;
  populations: ExportPopulation[];
  variants: ExportVariant[];
  metadata: ExportMetadata;
}
```

Export from src/types/index.ts:
```typescript
export type {
  ExportMetadata,
  ExportSummary,
  ExportPopulation,
  ExportVariant,
  ExportData,
} from './export';
```
  </action>
  <verify>`bun run typecheck` passes, xlsx listed in package.json dependencies</verify>
  <done>xlsx installed, export types defined and exported</done>
</task>

<task type="auto">
  <name>Task 2: Create export utility functions</name>
  <files>src/utils/export-utils.ts</files>
  <action>
Create pure utility functions for export formatting:

```typescript
import type {
  CarrierFrequencyResult,
  PopulationFrequency,
  DisplayVariant,
  FilterConfig,
  ExportSummary,
  ExportPopulation,
  ExportVariant,
  ExportMetadata,
  ExportData,
} from '@/types';
import type { GnomadVersion } from '@/config';
import { getGnomadVersion } from '@/config';
import { config } from '@/config';

/**
 * Sanitize filename by removing/replacing unsafe characters
 */
export function sanitizeFilename(name: string): string {
  return name
    .replace(/[<>:"/\\|?*]/g, '') // Remove Windows-unsafe chars
    .replace(/\s+/g, '_') // Replace spaces with underscores
    .trim();
}

/**
 * Generate export filename: gene_YYYY-MM-DD
 */
export function generateFilename(gene: string, population?: string): string {
  const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const sanitizedGene = sanitizeFilename(gene);
  if (population) {
    const sanitizedPop = sanitizeFilename(population);
    return `${sanitizedGene}_${sanitizedPop}_${date}`;
  }
  return `${sanitizedGene}_${date}`;
}

/**
 * Format date for display in exports
 */
export function formatExportDate(): string {
  return new Date().toISOString();
}

/**
 * Format frequency as percent string
 */
function formatPercent(freq: number | null): string {
  if (freq === null) return 'Not detected';
  return `${(freq * 100).toFixed(config.settings.frequencyDecimalPlaces)}%`;
}

/**
 * Format frequency as ratio string
 */
function formatRatio(freq: number | null): string {
  if (freq === null || freq === 0) return '-';
  return `1:${Math.round(1 / freq).toLocaleString()}`;
}

/**
 * Build ExportSummary from calculation result
 */
export function buildExportSummary(result: CarrierFrequencyResult): ExportSummary {
  return {
    gene: result.gene,
    globalCarrierFrequency: result.globalCarrierFrequency,
    globalCarrierFrequencyPercent: formatPercent(result.globalCarrierFrequency),
    globalCarrierFrequencyRatio: formatRatio(result.globalCarrierFrequency),
    globalAlleleCount: result.globalAlleleCount,
    globalAlleleNumber: result.globalAlleleNumber,
    qualifyingVariantCount: result.qualifyingVariantCount,
    minFrequency: result.minFrequency,
    maxFrequency: result.maxFrequency,
    hasFounderEffect: result.hasFounderEffect,
  };
}

/**
 * Build ExportPopulation array from populations
 */
export function buildExportPopulations(populations: PopulationFrequency[]): ExportPopulation[] {
  return populations.map(pop => ({
    code: pop.code,
    label: pop.label,
    carrierFrequency: pop.carrierFrequency,
    carrierFrequencyPercent: formatPercent(pop.carrierFrequency),
    carrierFrequencyRatio: formatRatio(pop.carrierFrequency),
    alleleCount: pop.alleleCount,
    alleleNumber: pop.alleleNumber,
    isFounderEffect: pop.isFounderEffect,
  }));
}

/**
 * Build ExportVariant array from display variants
 */
export function buildExportVariants(variants: DisplayVariant[]): ExportVariant[] {
  return variants.map(v => ({
    variantId: v.variantId,
    consequence: v.consequence,
    alleleFrequency: v.alleleFrequency,
    alleleFrequencyPercent: formatPercent(v.alleleFrequency),
    alleleCount: v.alleleCount,
    alleleNumber: v.alleleNumber,
    hgvsC: v.hgvsC,
    hgvsP: v.hgvsP,
    clinvarStatus: v.clinvarStatus,
    isLoF: v.isLoF,
    isClinvarPathogenic: v.isClinvarPathogenic,
  }));
}

/**
 * Build ExportMetadata
 */
export function buildExportMetadata(
  version: GnomadVersion,
  filters: FilterConfig
): ExportMetadata {
  const versionConfig = getGnomadVersion(version);
  return {
    exportDate: formatExportDate(),
    gnomadVersion: version,
    gnomadDisplayName: versionConfig.displayName,
    filtersApplied: { ...filters },
    appVersion: import.meta.env.VITE_APP_VERSION || 'unknown',
  };
}

/**
 * Build complete ExportData object
 */
export function buildExportData(
  result: CarrierFrequencyResult,
  variants: DisplayVariant[],
  filters: FilterConfig
): ExportData {
  return {
    summary: buildExportSummary(result),
    populations: buildExportPopulations(result.populations),
    variants: buildExportVariants(variants),
    metadata: buildExportMetadata(result.version, filters),
  };
}
```
  </action>
  <verify>`bun run typecheck` passes, utility functions have no runtime errors</verify>
  <done>Export utility functions provide data formatting and filename generation</done>
</task>

<task type="auto">
  <name>Task 3: Create useExport composable</name>
  <files>src/composables/useExport.ts, src/composables/index.ts</files>
  <action>
Create composable with JSON and Excel export methods:

```typescript
import * as XLSX from 'xlsx';
import type { ExportData } from '@/types';
import { generateFilename } from '@/utils/export-utils';

/**
 * Download a blob as a file
 */
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Composable for exporting calculation results
 */
export function useExport() {
  /**
   * Export data as JSON file
   */
  function exportToJson(data: ExportData, gene: string, population?: string): void {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const filename = generateFilename(gene, population) + '.json';
    downloadBlob(blob, filename);
  }

  /**
   * Export data as Excel file with multiple sheets
   */
  function exportToExcel(data: ExportData, gene: string, population?: string): void {
    const wb = XLSX.utils.book_new();

    // Summary sheet (single row)
    const summaryWs = XLSX.utils.json_to_sheet([data.summary]);
    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');

    // Populations sheet
    if (data.populations.length > 0) {
      const populationsWs = XLSX.utils.json_to_sheet(data.populations);
      XLSX.utils.book_append_sheet(wb, populationsWs, 'Populations');
    }

    // Variants sheet
    if (data.variants.length > 0) {
      const variantsWs = XLSX.utils.json_to_sheet(data.variants);
      XLSX.utils.book_append_sheet(wb, variantsWs, 'Variants');
    }

    // Metadata sheet (flatten for readability)
    const metadataRows = [
      { field: 'Export Date', value: data.metadata.exportDate },
      { field: 'gnomAD Version', value: data.metadata.gnomadVersion },
      { field: 'gnomAD Display Name', value: data.metadata.gnomadDisplayName },
      { field: 'App Version', value: data.metadata.appVersion },
      { field: 'LoF HC Filter', value: String(data.metadata.filtersApplied.lofHcEnabled) },
      { field: 'Missense Filter', value: String(data.metadata.filtersApplied.missenseEnabled) },
      { field: 'ClinVar Filter', value: String(data.metadata.filtersApplied.clinvarEnabled) },
      { field: 'ClinVar Star Threshold', value: String(data.metadata.filtersApplied.clinvarStarThreshold) },
    ];
    const metadataWs = XLSX.utils.json_to_sheet(metadataRows);
    XLSX.utils.book_append_sheet(wb, metadataWs, 'Metadata');

    // Generate and download file
    const filename = generateFilename(gene, population) + '.xlsx';
    XLSX.writeFile(wb, filename);
  }

  /**
   * Export logs as JSON file (for LogViewer)
   */
  function exportLogsToJson(entries: unknown[], stats: unknown): void {
    const data = {
      exportDate: new Date().toISOString(),
      stats,
      entries,
    };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const filename = `carrier-freq-logs_${new Date().toISOString().split('T')[0]}.json`;
    downloadBlob(blob, filename);
  }

  return {
    exportToJson,
    exportToExcel,
    exportLogsToJson,
  };
}
```

Update src/composables/index.ts:
```typescript
export { useExport } from './useExport';
```
  </action>
  <verify>`bun run typecheck` passes, `bun run build` succeeds with xlsx bundled</verify>
  <done>useExport composable provides JSON and Excel export methods</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` - all types resolve
2. `bun run build` - xlsx bundled without errors
3. `bun run lint` - no ESLint errors
4. Export types importable: `import type { ExportData } from '@/types'`
5. Composable importable: `import { useExport } from '@/composables'`
</verification>

<success_criteria>
- EXP-01 foundation: exportToJson method ready for JSON export
- EXP-02 foundation: exportToExcel method creates multi-sheet Excel
- EXP-03: Export types include gene, populations, frequencies, calculated risks
- EXP-04: ExportMetadata includes gnomAD version, date, filters used
- LOG-05 foundation: exportLogsToJson ready for log download
</success_criteria>

<output>
After completion, create `.planning/phases/10-export-templates-logging/10-02-SUMMARY.md`
</output>
