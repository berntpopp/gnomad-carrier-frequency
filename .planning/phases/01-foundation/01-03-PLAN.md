---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/types/index.ts
  - src/types/variant.ts
  - src/types/frequency.ts
  - src/utils/frequency-calc.ts
  - src/utils/variant-filters.ts
  - src/utils/formatters.ts
  - src/api/client.ts
  - src/api/index.ts
  - src/main.ts
autonomous: true

must_haves:
  truths:
    - "Carrier frequency calculated as 2 x sum(pathogenic allele frequencies)"
    - "Recurrence risk for heterozygous carrier is carrier_freq / 4"
    - "Recurrence risk for compound het/homozygous is carrier_freq / 2"
    - "LoF HC variants are correctly identified"
    - "ClinVar pathogenic variants with >=1 star are correctly identified"
    - "AN=0 populations return null (Not detected), not 0"
    - "All thresholds come from config, not hardcoded"
    - "GraphQL client uses API endpoint from config"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Re-exports all type definitions"
      exports: ["PopulationFrequency", "VariantData", "CarrierFrequencyResult"]
    - path: "src/utils/frequency-calc.ts"
      provides: "Carrier frequency and recurrence risk calculations"
      exports: ["calculateCarrierFrequency", "calculateRecurrenceRisk", "calculateAlleleFrequency"]
    - path: "src/utils/variant-filters.ts"
      provides: "LoF and ClinVar filtering functions"
      exports: ["isHighConfidenceLoF", "isPathogenicClinVar", "shouldIncludeVariant"]
    - path: "src/utils/formatters.ts"
      provides: "Display formatting (percentage, ratio)"
      exports: ["frequencyToPercent", "frequencyToRatio"]
    - path: "src/api/client.ts"
      provides: "Version-aware GraphQL client"
      exports: ["createGnomadClient", "useGnomadClient"]
  key_links:
    - from: "src/utils/frequency-calc.ts"
      to: "src/config/index.ts"
      via: "config import for thresholds"
      pattern: "import.*config.*from.*@/config"
    - from: "src/api/client.ts"
      to: "src/config/index.ts"
      via: "config import for API endpoint"
      pattern: "import.*getApiEndpoint.*from.*@/config"
---

<objective>
Create TypeScript type definitions, pure calculation functions, and version-aware GraphQL client setup.

Purpose: Establish the core domain logic as testable pure functions that read all configuration from the config module. No hardcoded values - everything comes from config. Also set up the villus GraphQL client with version-aware endpoint selection.
Output: Type-safe utility modules and GraphQL client, all using centralized config.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type definitions</name>
  <files>
    - src/types/index.ts
    - src/types/variant.ts
    - src/types/frequency.ts
  </files>
  <action>
Create comprehensive TypeScript types for the domain.

**IMPORTANT:** Population codes are NOT defined here - they come from config. Types should work with any string population code.

1. src/types/variant.ts:
   ```typescript
   export interface TranscriptConsequence {
     gene_symbol: string;
     transcript_id: string;
     canonical: boolean;
     consequence_terms: string[];
     lof: string | null;        // "HC", "LC", "OS", or null
     lof_filter: string | null;
     lof_flags: string | null;
   }

   export interface ClinVarVariant {
     variant_id: string;
     clinical_significance: string;
     gold_stars: number;
     review_status: string;
     pos: number;
     ref: string;
     alt: string;
   }

   export interface VariantPopulation {
     id: string;  // Population code from config
     ac: number;
     an: number;
   }

   export interface VariantFrequencyData {
     exome?: {
       ac: number;
       an: number;
       populations: VariantPopulation[];
     };
     genome?: {
       ac: number;
       an: number;
       populations: VariantPopulation[];
     };
   }

   export interface GnomadVariant {
     variant_id: string;
     pos: number;
     ref: string;
     alt: string;
     exome?: VariantFrequencyData['exome'];
     genome?: VariantFrequencyData['genome'];
     transcript_consequences: TranscriptConsequence[];
   }
   ```

2. src/types/frequency.ts:
   ```typescript
   import type { GnomadVersion } from '@/config';

   export type IndexPatientStatus = 'heterozygous' | 'compound_het_homozygous';

   export interface PopulationFrequency {
     code: string;  // Dynamic from config, not hardcoded
     label: string;
     carrierFrequency: number | null;  // null = not detected (AN=0)
     alleleCount: number;
     alleleNumber: number;
     isLowSampleSize: boolean;
     isFounderEffect: boolean;
   }

   export interface CarrierFrequencyResult {
     gene: string;
     version: GnomadVersion;
     globalCarrierFrequency: number | null;
     populations: PopulationFrequency[];
     qualifyingVariantCount: number;
     minFrequency: number | null;
     maxFrequency: number | null;
     hasFounderEffect: boolean;
   }

   export interface RecurrenceRiskResult {
     carrierFrequency: number;
     indexStatus: IndexPatientStatus;
     recurrenceRisk: number;
     recurrenceRiskPercent: string;
     recurrenceRiskRatio: string;
   }
   ```

3. src/types/index.ts:
   - Re-export all types from variant.ts, frequency.ts
  </action>
  <verify>
- `bunx tsc --noEmit src/types/index.ts` should pass
- Types should be importable without errors
- No hardcoded population codes in types
  </verify>
  <done>
- All type files created and export correctly
- TypeScript compiler accepts all type definitions
- Types reference config for GnomadVersion
- Population codes are string type (dynamic from config)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create calculation and filter functions using config</name>
  <files>
    - src/utils/frequency-calc.ts
    - src/utils/variant-filters.ts
    - src/utils/formatters.ts
  </files>
  <action>
Implement pure calculation functions that read ALL thresholds from config:

1. src/utils/frequency-calc.ts:
   ```typescript
   import { config, getPopulationLabel, getPopulationCodes, type GnomadVersion } from '@/config';
   import type { IndexPatientStatus, PopulationFrequency } from '@/types';
   import type { VariantFrequencyData } from '@/types/variant';

   // All thresholds from config - NO MAGIC NUMBERS
   const { lowSampleSizeThreshold, founderEffectMultiplier } = config.settings;

   export function calculateAlleleFrequency(ac: number, an: number): number | null {
     if (an === 0) return null;
     return ac / an;
   }

   export function calculateCarrierFrequency(pathogenicAFs: number[]): number {
     // CALC-01: Carrier frequency = 2 x sum(pathogenic allele frequencies)
     const sumAF = pathogenicAFs.reduce((sum, af) => sum + af, 0);
     return 2 * sumAF;
   }

   export function calculateRecurrenceRisk(
     carrierFrequency: number,
     indexStatus: IndexPatientStatus
   ): number {
     // CALC-02: Heterozygous carrier: carrier_freq / 4
     // CALC-03: Compound het/homozygous: carrier_freq / 2
     return indexStatus === 'heterozygous'
       ? carrierFrequency / 4
       : carrierFrequency / 2;
   }

   export function aggregatePopulationFrequencies(
     variants: VariantFrequencyData[],
     version: GnomadVersion
   ): Map<string, { totalAC: number; maxAN: number }> {
     const result = new Map<string, { totalAC: number; maxAN: number }>();

     // Get population codes from config for this version
     const populationCodes = getPopulationCodes(version);

     // Initialize all populations from config
     for (const pop of populationCodes) {
       result.set(pop, { totalAC: 0, maxAN: 0 });
     }

     for (const variant of variants) {
       const allPopulations = [
         ...(variant.exome?.populations ?? []),
         ...(variant.genome?.populations ?? []),
       ];

       for (const pop of allPopulations) {
         if (populationCodes.includes(pop.id)) {
           const current = result.get(pop.id)!;
           current.totalAC += pop.ac;
           current.maxAN = Math.max(current.maxAN, pop.an);
         }
       }
     }

     return result;
   }

   export function buildPopulationFrequencies(
     aggregated: Map<string, { totalAC: number; maxAN: number }>,
     globalCarrierFrequency: number | null,
     version: GnomadVersion
   ): PopulationFrequency[] {
     const results: PopulationFrequency[] = [];

     for (const [code, data] of aggregated) {
       const af = calculateAlleleFrequency(data.totalAC, data.maxAN);
       const carrierFreq = af !== null ? 2 * af : null;

       // Use thresholds from config
       const isFounderEffect = globalCarrierFrequency !== null &&
         carrierFreq !== null &&
         carrierFreq > globalCarrierFrequency * founderEffectMultiplier;

       results.push({
         code,
         label: getPopulationLabel(code, version),  // Label from config
         carrierFrequency: carrierFreq,
         alleleCount: data.totalAC,
         alleleNumber: data.maxAN,
         isLowSampleSize: data.maxAN < lowSampleSizeThreshold,  // Threshold from config
         isFounderEffect,
       });
     }

     // Sort by carrier frequency descending (nulls at end)
     return results.sort((a, b) => {
       if (a.carrierFrequency === null) return 1;
       if (b.carrierFrequency === null) return -1;
       return b.carrierFrequency - a.carrierFrequency;
     });
   }
   ```

2. src/utils/variant-filters.ts:
   ```typescript
   import type { TranscriptConsequence, ClinVarVariant, GnomadVariant } from '@/types/variant';

   export function isHighConfidenceLoF(consequence: TranscriptConsequence): boolean {
     // FILT-01: LoF "HC" (high confidence) from LOFTEE
     // Only consider canonical transcript
     return consequence.canonical && consequence.lof === 'HC';
   }

   export function isPathogenicClinVar(variant: ClinVarVariant): boolean {
     // FILT-02: ClinVar pathogenic/likely pathogenic
     // FILT-03: Require >= 1 review star
     const sig = variant.clinical_significance.toLowerCase();
     const isPathogenic =
       (sig.includes('pathogenic') || sig.includes('likely_pathogenic')) &&
       !sig.includes('conflicting');
     const hasReview = variant.gold_stars >= 1;
     return isPathogenic && hasReview;
   }

   export function shouldIncludeVariant(
     variant: GnomadVariant,
     clinvarVariants: ClinVarVariant[]
   ): boolean {
     // Include if: LoF HC OR ClinVar Pathogenic/Likely Pathogenic with >= 1 star
     const hasHCLoF = variant.transcript_consequences.some(isHighConfidenceLoF);

     const clinvarMatch = clinvarVariants.find(cv => cv.variant_id === variant.variant_id);
     const hasPathogenicClinVar = clinvarMatch ? isPathogenicClinVar(clinvarMatch) : false;

     return hasHCLoF || hasPathogenicClinVar;
   }

   export function filterPathogenicVariants(
     variants: GnomadVariant[],
     clinvarVariants: ClinVarVariant[]
   ): GnomadVariant[] {
     return variants.filter(v => shouldIncludeVariant(v, clinvarVariants));
   }
   ```

3. src/utils/formatters.ts:
   ```typescript
   import { config } from '@/config';

   // Decimal places from config
   const { frequencyDecimalPlaces } = config.settings;

   export function frequencyToPercent(frequency: number | null): string {
     if (frequency === null) return 'Not detected';
     return `${(frequency * 100).toFixed(frequencyDecimalPlaces)}%`;
   }

   export function frequencyToRatio(frequency: number | null): string {
     if (frequency === null) return 'Not detected';
     if (frequency === 0) return 'Not detected';
     const ratio = Math.round(1 / frequency);
     return `1:${ratio.toLocaleString()}`;
   }

   export function formatCarrierFrequency(frequency: number | null): {
     percent: string;
     ratio: string;
   } {
     return {
       percent: frequencyToPercent(frequency),
       ratio: frequencyToRatio(frequency),
     };
   }
   ```
  </action>
  <verify>
Verify no magic numbers exist:
- `grep -r "1000" src/utils/` should return nothing (lowSampleSizeThreshold from config)
- `grep -r "= 5" src/utils/` should return nothing (founderEffectMultiplier from config)
- `grep -r "= 2" src/utils/formatters.ts` should return nothing (frequencyDecimalPlaces from config)

Test functions manually:
```typescript
import { calculateCarrierFrequency, calculateRecurrenceRisk } from './frequency-calc';
import { frequencyToRatio } from './formatters';

// CFTR NFE ~4% carrier frequency = 1:25
const carrierFreq = 0.04;
console.assert(frequencyToRatio(carrierFreq) === '1:25', 'Ratio format');
console.assert(calculateRecurrenceRisk(0.04, 'heterozygous') === 0.01, 'Het risk');
```
  </verify>
  <done>
- All utility functions export correctly
- calculateCarrierFrequency implements 2 x sum(AF) formula
- calculateRecurrenceRisk returns carrier_freq/4 for het, carrier_freq/2 for hom
- NO hardcoded thresholds - all from config.settings
- Population labels come from config via getPopulationLabel()
- AN=0 cases return null, formatted as "Not detected"
  </done>
</task>

<task type="auto">
  <name>Task 3: Create version-aware GraphQL client</name>
  <files>
    - src/api/client.ts
    - src/api/index.ts
    - src/main.ts (update)
  </files>
  <action>
Create the GraphQL client that uses API endpoint from config:

1. src/api/client.ts:
   ```typescript
   import { createClient, type ClientPlugin } from 'villus';
   import { ref, computed, type Ref } from 'vue';
   import {
     getApiEndpoint,
     getGnomadVersion,
     type GnomadVersion,
   } from '@/config';

   // Current version state (reactive)
   const currentVersion = ref<GnomadVersion>(getGnomadVersion().version);

   // Create client with dynamic URL based on version
   // Note: All gnomAD versions use the same endpoint, but dataset differs
   // This structure allows for future API endpoint changes per version
   export function createGnomadClient(version?: GnomadVersion) {
     const v = version ?? currentVersion.value;
     const endpoint = getApiEndpoint(v);

     return createClient({
       url: endpoint,
     });
   }

   // Composable for accessing/changing version
   export function useGnomadVersion() {
     const version = computed(() => currentVersion.value);
     const versionConfig = computed(() => getGnomadVersion(currentVersion.value));

     const setVersion = (v: GnomadVersion) => {
       currentVersion.value = v;
     };

     return {
       version,
       versionConfig,
       setVersion,
     };
   }

   // Default client for app-wide use
   export const graphqlClient = createGnomadClient();
   ```

2. src/api/index.ts:
   ```typescript
   export {
     createGnomadClient,
     useGnomadVersion,
     graphqlClient,
   } from './client';
   ```

3. Update src/main.ts to use the client:
   ```typescript
   import { createApp } from 'vue';
   import { createVuetify } from 'vuetify';
   import { aliases, mdi } from 'vuetify/iconsets/mdi';
   import 'vuetify/styles';
   import '@mdi/font/css/materialdesignicons.css';

   import App from './App.vue';
   import { graphqlClient } from '@/api';

   const vuetify = createVuetify({
     icons: {
       defaultSet: 'mdi',
       aliases,
       sets: { mdi },
     },
     theme: {
       defaultTheme: 'light',
     },
   });

   const app = createApp(App);
   app.use(vuetify);
   app.use(graphqlClient);
   app.mount('#app');
   ```
  </action>
  <verify>
- No hardcoded API URL in client.ts (comes from getApiEndpoint)
- `grep -r "gnomad.broadinstitute.org" src/api/` should return nothing
- TypeScript compiles: `bunx tsc --noEmit`
- App still runs: `bun run dev`
  </verify>
  <done>
- GraphQL client created using endpoint from config
- useGnomadVersion() composable for version switching
- Client integrated into Vue app via app.use()
- No hardcoded URLs in API layer
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiler accepts all files: `bunx tsc --noEmit`
2. No magic numbers in utils: `grep -rE "[0-9]{3,}" src/utils/` should show only imports
3. No hardcoded URLs: `grep -r "gnomad.broadinstitute.org" src/` should only show config JSON
4. calculateCarrierFrequency([0.02]) returns 0.04 (2 x AF)
5. frequencyToRatio(0.04) returns "1:25"
6. `bun run dev` starts successfully with GraphQL client configured
</verification>

<success_criteria>
- All types defined and exported from src/types/index.ts
- All utility functions are pure (no side effects, no Vue dependencies except formatters config import)
- Carrier frequency formula: 2 x sum(pathogenic AFs) (CALC-01)
- Recurrence risk formulas correct (CALC-02, CALC-03)
- Display formats include both % and ratio (CALC-04)
- LoF filter checks canonical + HC (FILT-01)
- ClinVar filter checks P/LP + stars >= 1 (FILT-02, FILT-03)
- Population handling uses config for codes, labels, thresholds
- GraphQL client uses config for API endpoint
- ZERO hardcoded values in src/utils/ or src/api/
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
