---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/types/population.ts
  - src/types/variant.ts
  - src/types/frequency.ts
  - src/utils/frequency-calc.ts
  - src/utils/variant-filters.ts
  - src/utils/formatters.ts
autonomous: true

must_haves:
  truths:
    - "Carrier frequency calculated as 2 x sum(pathogenic allele frequencies)"
    - "Recurrence risk for heterozygous carrier is carrier_freq / 4"
    - "Recurrence risk for compound het/homozygous is carrier_freq / 2"
    - "LoF HC variants are correctly identified"
    - "ClinVar pathogenic variants with >=1 star are correctly identified"
    - "AN=0 populations return null (Not detected), not 0"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Re-exports all type definitions"
      exports: ["PopulationCode", "PopulationFrequency", "VariantData", "CarrierFrequencyResult"]
    - path: "src/utils/frequency-calc.ts"
      provides: "Carrier frequency and recurrence risk calculations"
      exports: ["calculateCarrierFrequency", "calculateRecurrenceRisk", "calculateAlleleFrequency"]
    - path: "src/utils/variant-filters.ts"
      provides: "LoF and ClinVar filtering functions"
      exports: ["isHighConfidenceLoF", "isPathogenicClinVar", "shouldIncludeVariant"]
    - path: "src/utils/formatters.ts"
      provides: "Display formatting (percentage, ratio)"
      exports: ["frequencyToPercent", "frequencyToRatio"]
  key_links:
    - from: "src/utils/frequency-calc.ts"
      to: "src/types/population.ts"
      via: "type imports"
      pattern: "import.*PopulationCode"
    - from: "src/utils/variant-filters.ts"
      to: "src/types/variant.ts"
      via: "type imports"
      pattern: "import.*TranscriptConsequence"
---

<objective>
Create TypeScript type definitions and pure calculation functions for carrier frequency, recurrence risk, and variant filtering.

Purpose: Establish the core domain logic as testable pure functions before wiring to UI or API. These functions implement CALC-01 through CALC-04, FILT-01 through FILT-03, and POP-01 through POP-04 requirements.
Output: Type-safe utility modules that can be unit tested independently.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type definitions</name>
  <files>
    - src/types/index.ts
    - src/types/population.ts
    - src/types/variant.ts
    - src/types/frequency.ts
  </files>
  <action>
Create comprehensive TypeScript types for the domain:

1. src/types/population.ts:
   ```typescript
   // gnomAD v4 population codes
   export const POPULATION_CODES = ['afr', 'amr', 'asj', 'eas', 'fin', 'mid', 'nfe', 'sas'] as const;
   export type PopulationCode = typeof POPULATION_CODES[number];

   export const POPULATION_LABELS: Record<PopulationCode, string> = {
     afr: 'African/African-American',
     amr: 'Admixed American',
     asj: 'Ashkenazi Jewish',
     eas: 'East Asian',
     fin: 'Finnish',
     mid: 'Middle Eastern',
     nfe: 'Non-Finnish European',
     sas: 'South Asian',
   };

   export interface PopulationData {
     id: string;
     ac: number;  // allele count
     an: number;  // allele number
   }

   export interface PopulationFrequency {
     code: PopulationCode;
     label: string;
     carrierFrequency: number | null;  // null = not detected (AN=0)
     alleleCount: number;
     alleleNumber: number;
     isLowSampleSize: boolean;  // AN < 1000
     isFounderEffect: boolean;  // >5x global frequency
   }
   ```

2. src/types/variant.ts:
   ```typescript
   export interface TranscriptConsequence {
     gene_symbol: string;
     transcript_id: string;
     canonical: boolean;
     consequence_terms: string[];
     lof: string | null;        // "HC", "LC", "OS", or null
     lof_filter: string | null;
     lof_flags: string | null;
   }

   export interface ClinVarVariant {
     variant_id: string;
     clinical_significance: string;
     gold_stars: number;
     review_status: string;
     pos: number;
     ref: string;
     alt: string;
   }

   export interface VariantPopulation {
     id: string;
     ac: number;
     an: number;
   }

   export interface VariantFrequencyData {
     exome?: {
       ac: number;
       an: number;
       populations: VariantPopulation[];
     };
     genome?: {
       ac: number;
       an: number;
       populations: VariantPopulation[];
     };
   }

   export interface GnomadVariant {
     variant_id: string;
     pos: number;
     ref: string;
     alt: string;
     exome?: VariantFrequencyData['exome'];
     genome?: VariantFrequencyData['genome'];
     transcript_consequences: TranscriptConsequence[];
   }
   ```

3. src/types/frequency.ts:
   ```typescript
   import type { PopulationFrequency } from './population';

   export type IndexPatientStatus = 'heterozygous' | 'compound_het_homozygous';

   export interface CarrierFrequencyResult {
     gene: string;
     globalCarrierFrequency: number | null;
     populations: PopulationFrequency[];
     qualifyingVariantCount: number;
     minFrequency: number | null;
     maxFrequency: number | null;
     hasFounderEffect: boolean;
   }

   export interface RecurrenceRiskResult {
     carrierFrequency: number;
     indexStatus: IndexPatientStatus;
     recurrenceRisk: number;
     recurrenceRiskPercent: string;
     recurrenceRiskRatio: string;
   }
   ```

4. src/types/index.ts:
   - Re-export all types from population.ts, variant.ts, frequency.ts
  </action>
  <verify>
Create a temporary test file or use TypeScript compiler:
- `bunx tsc --noEmit src/types/index.ts` should pass
- Types should be importable without errors
  </verify>
  <done>
- All type files created and export correctly
- TypeScript compiler accepts all type definitions
- PopulationCode is a union of 8 literal strings
- Types match gnomAD API response structure from research
  </done>
</task>

<task type="auto">
  <name>Task 2: Create calculation and filter functions</name>
  <files>
    - src/utils/frequency-calc.ts
    - src/utils/variant-filters.ts
    - src/utils/formatters.ts
  </files>
  <action>
Implement pure calculation functions (no Vue dependencies):

1. src/utils/frequency-calc.ts:
   ```typescript
   import type { PopulationCode, PopulationData, PopulationFrequency, POPULATION_CODES, POPULATION_LABELS } from '@/types';
   import type { IndexPatientStatus, VariantFrequencyData } from '@/types';

   const LOW_SAMPLE_THRESHOLD = 1000;
   const FOUNDER_EFFECT_MULTIPLIER = 5;

   export function calculateAlleleFrequency(ac: number, an: number): number | null {
     if (an === 0) return null;
     return ac / an;
   }

   export function calculateCarrierFrequency(pathogenicAFs: number[]): number {
     // CALC-01: Carrier frequency = 2 x sum(pathogenic allele frequencies)
     const sumAF = pathogenicAFs.reduce((sum, af) => sum + af, 0);
     return 2 * sumAF;
   }

   export function calculateRecurrenceRisk(
     carrierFrequency: number,
     indexStatus: IndexPatientStatus
   ): number {
     // CALC-02: Heterozygous carrier: 1/2 x carrier_freq x 1/2 = carrier_freq / 4
     // CALC-03: Compound het/homozygous: 1 x carrier_freq x 1/2 = carrier_freq / 2
     return indexStatus === 'heterozygous'
       ? carrierFrequency / 4
       : carrierFrequency / 2;
   }

   export function aggregatePopulationFrequencies(
     variants: VariantFrequencyData[],
     populationCodes: readonly PopulationCode[] = POPULATION_CODES
   ): Map<PopulationCode, { totalAC: number; maxAN: number }> {
     const result = new Map<PopulationCode, { totalAC: number; maxAN: number }>();

     // Initialize all populations
     for (const pop of populationCodes) {
       result.set(pop, { totalAC: 0, maxAN: 0 });
     }

     for (const variant of variants) {
       const allPopulations = [
         ...(variant.exome?.populations ?? []),
         ...(variant.genome?.populations ?? []),
       ];

       for (const pop of allPopulations) {
         const code = pop.id as PopulationCode;
         if (populationCodes.includes(code)) {
           const current = result.get(code)!;
           current.totalAC += pop.ac;
           current.maxAN = Math.max(current.maxAN, pop.an);
         }
       }
     }

     return result;
   }

   export function buildPopulationFrequencies(
     aggregated: Map<PopulationCode, { totalAC: number; maxAN: number }>,
     globalCarrierFrequency: number | null
   ): PopulationFrequency[] {
     const results: PopulationFrequency[] = [];

     for (const [code, data] of aggregated) {
       const af = calculateAlleleFrequency(data.totalAC, data.maxAN);
       const carrierFreq = af !== null ? 2 * af : null;

       const isFounderEffect = globalCarrierFrequency !== null &&
         carrierFreq !== null &&
         carrierFreq > globalCarrierFrequency * FOUNDER_EFFECT_MULTIPLIER;

       results.push({
         code,
         label: POPULATION_LABELS[code],
         carrierFrequency: carrierFreq,
         alleleCount: data.totalAC,
         alleleNumber: data.maxAN,
         isLowSampleSize: data.maxAN < LOW_SAMPLE_THRESHOLD,
         isFounderEffect,
       });
     }

     // Sort by carrier frequency descending (nulls at end)
     return results.sort((a, b) => {
       if (a.carrierFrequency === null) return 1;
       if (b.carrierFrequency === null) return -1;
       return b.carrierFrequency - a.carrierFrequency;
     });
   }
   ```

2. src/utils/variant-filters.ts:
   ```typescript
   import type { TranscriptConsequence, ClinVarVariant, GnomadVariant } from '@/types';

   export function isHighConfidenceLoF(consequence: TranscriptConsequence): boolean {
     // FILT-01: LoF "HC" (high confidence) from LOFTEE
     // Only consider canonical transcript
     return consequence.canonical && consequence.lof === 'HC';
   }

   export function isPathogenicClinVar(variant: ClinVarVariant): boolean {
     // FILT-02: ClinVar pathogenic/likely pathogenic
     // FILT-03: Require >= 1 review star
     const sig = variant.clinical_significance.toLowerCase();
     const isPathogenic =
       (sig.includes('pathogenic') || sig.includes('likely_pathogenic')) &&
       !sig.includes('conflicting');
     const hasReview = variant.gold_stars >= 1;
     return isPathogenic && hasReview;
   }

   export function shouldIncludeVariant(
     variant: GnomadVariant,
     clinvarVariants: ClinVarVariant[]
   ): boolean {
     // Include if: LoF HC OR ClinVar Pathogenic/Likely Pathogenic with >= 1 star
     const hasHCLoF = variant.transcript_consequences.some(isHighConfidenceLoF);

     const clinvarMatch = clinvarVariants.find(cv => cv.variant_id === variant.variant_id);
     const hasPathogenicClinVar = clinvarMatch ? isPathogenicClinVar(clinvarMatch) : false;

     return hasHCLoF || hasPathogenicClinVar;
   }

   export function filterPathogenicVariants(
     variants: GnomadVariant[],
     clinvarVariants: ClinVarVariant[]
   ): GnomadVariant[] {
     return variants.filter(v => shouldIncludeVariant(v, clinvarVariants));
   }
   ```

3. src/utils/formatters.ts:
   ```typescript
   // CALC-04: Display as both percentage and ratio

   export function frequencyToPercent(frequency: number | null, decimals = 2): string {
     if (frequency === null) return 'Not detected';
     return `${(frequency * 100).toFixed(decimals)}%`;
   }

   export function frequencyToRatio(frequency: number | null): string {
     if (frequency === null) return 'Not detected';
     if (frequency === 0) return 'Not detected';
     const ratio = Math.round(1 / frequency);
     return `1:${ratio.toLocaleString()}`;
   }

   export function formatCarrierFrequency(frequency: number | null): {
     percent: string;
     ratio: string;
   } {
     return {
       percent: frequencyToPercent(frequency),
       ratio: frequencyToRatio(frequency),
     };
   }
   ```
  </action>
  <verify>
Test the functions manually or with inline assertions:

```typescript
// Quick verification (can add to a test file)
import { calculateCarrierFrequency, calculateRecurrenceRisk } from './frequency-calc';
import { frequencyToRatio, frequencyToPercent } from './formatters';

// CFTR NFE ~4% carrier frequency = 1:25
const carrierFreq = 0.04;
console.assert(frequencyToRatio(carrierFreq) === '1:25', 'Ratio format');
console.assert(frequencyToPercent(carrierFreq) === '4.00%', 'Percent format');

// Recurrence risk
console.assert(calculateRecurrenceRisk(0.04, 'heterozygous') === 0.01, 'Het risk');
console.assert(calculateRecurrenceRisk(0.04, 'compound_het_homozygous') === 0.02, 'Hom risk');
```
  </verify>
  <done>
- All utility functions export correctly
- calculateCarrierFrequency implements 2 x sum(AF) formula
- calculateRecurrenceRisk returns carrier_freq/4 for het, carrier_freq/2 for hom
- frequencyToRatio produces "1:25" format
- frequencyToPercent produces "4.00%" format
- AN=0 cases return null, formatted as "Not detected"
- isHighConfidenceLoF checks canonical + lof === "HC"
- isPathogenicClinVar checks P/LP + gold_stars >= 1
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiler accepts all files: `bunx tsc --noEmit`
2. Types correctly model gnomAD API responses
3. calculateCarrierFrequency(0.02) returns 0.04 (2 x AF)
4. frequencyToRatio(0.04) returns "1:25"
5. isHighConfidenceLoF returns true only for canonical + HC
6. isPathogenicClinVar returns true only for P/LP with >= 1 star
</verification>

<success_criteria>
- All types defined and exported from src/types/index.ts
- All utility functions are pure (no side effects, no Vue dependencies)
- Carrier frequency formula: 2 x sum(pathogenic AFs) (CALC-01)
- Recurrence risk formulas correct (CALC-02, CALC-03)
- Display formats include both % and ratio (CALC-04)
- LoF filter checks canonical + HC (FILT-01)
- ClinVar filter checks P/LP + stars >= 1 (FILT-02, FILT-03)
- Population handling includes founder effect detection (POP-04)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
