---
phase: 07-seo-accessibility
plan: 03
type: execute
wave: 2
depends_on: ["07-02"]
files_modified:
  - src/components/wizard/WizardStepper.vue
  - src/components/SettingsDialog.vue
autonomous: true

must_haves:
  truths:
    - "Screen reader announces step changes when navigating wizard"
    - "Screen reader announces calculation results on Step 4"
    - "Screen reader announces errors when API calls fail"
    - "Focus is trapped inside SettingsDialog when open"
    - "Focus returns to trigger element when dialog closes"
  artifacts:
    - path: "src/components/wizard/WizardStepper.vue"
      provides: "Wizard with ARIA announcements"
      contains: "useAppAnnouncer"
    - path: "src/components/SettingsDialog.vue"
      provides: "Dialog with focus trap"
      contains: "useFocusTrap"
  key_links:
    - from: "src/components/wizard/WizardStepper.vue"
      to: "src/composables/useAppAnnouncer.ts"
      via: "composable import"
      pattern: "useAppAnnouncer"
    - from: "src/components/SettingsDialog.vue"
      to: "@vueuse/integrations/useFocusTrap"
      via: "composable import"
      pattern: "useFocusTrap"
---

<objective>
Integrate ARIA announcements in the wizard flow and add focus trap to SettingsDialog.

Purpose: Complete the screen reader experience (SEO-04) and modal focus management (SEO-05). Users relying on assistive technology will hear step changes, calculation results, and errors. Focus will be properly trapped in modal dialogs.

Output: WizardStepper with announcements, SettingsDialog with focus trap
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-seo-accessibility/07-RESEARCH.md
@.planning/phases/07-seo-accessibility/07-CONTEXT.md
@.planning/phases/07-seo-accessibility/07-02-SUMMARY.md
@src/components/wizard/WizardStepper.vue
@src/components/SettingsDialog.vue
@src/composables/useAppAnnouncer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate announcements in WizardStepper</name>
  <files>src/components/wizard/WizardStepper.vue</files>
  <action>
Update WizardStepper.vue to use useAppAnnouncer for screen reader announcements.

1. Import the composable:
```typescript
import { useAppAnnouncer } from '@/composables';
```

2. Initialize in setup:
```typescript
const {
  announceStep,
  announceCalculation,
  announceError,
  announceLoading,
  announceGeneSelection,
} = useAppAnnouncer();
```

3. Add step name mapping:
```typescript
const stepNames = ['Gene', 'Status', 'Frequency', 'Results'];
```

4. Watch for step changes and announce:
```typescript
watch(
  () => state.currentStep,
  (newStep, oldStep) => {
    if (newStep !== oldStep && newStep >= 1 && newStep <= 4) {
      announceStep(newStep, stepNames[newStep - 1]);
    }
  }
);
```

5. Announce when gene is selected in onGeneComplete:
```typescript
function onGeneComplete() {
  if (state.gene) {
    announceGeneSelection(state.gene.symbol);
  }
  nextStep();
}
```

6. Watch for loading state and announce:
```typescript
watch(
  isLoading,
  (loading, wasLoading) => {
    if (loading && !wasLoading) {
      announceLoading('variant data');
    } else if (!loading && wasLoading && !hasError.value) {
      announceLoading('Variant data', true);
    }
  }
);
```

7. Watch for errors and announce:
```typescript
watch(
  hasError,
  (error) => {
    if (error && errorMessage.value) {
      announceError(errorMessage.value);
    }
  }
);
```

8. When reaching results step (step 4), announce calculation:
Add to existing step change watcher:
```typescript
watch(
  () => state.currentStep,
  (newStep, oldStep) => {
    if (newStep !== oldStep && newStep >= 1 && newStep <= 4) {
      announceStep(newStep, stepNames[newStep - 1]);

      // Announce results when reaching step 4
      if (newStep === 4 && globalFrequency.value !== null) {
        const ratio = `1 in ${Math.round(1 / globalFrequency.value)}`;
        announceCalculation(ratio, 'global');
      }
    }
  }
);
```

Important: Avoid over-announcing. Only announce state changes, not initial states.
  </action>
  <verify>`bun run typecheck` passes, manual testing with screen reader shows announcements</verify>
  <done>WizardStepper announces step changes, gene selection, loading, errors, and results</done>
</task>

<task type="auto">
  <name>Task 2: Add focus trap to SettingsDialog</name>
  <files>src/components/SettingsDialog.vue</files>
  <action>
Update SettingsDialog.vue to trap focus when dialog is open.

1. Import useFocusTrap:
```typescript
import { ref, nextTick } from 'vue';
import { useFocusTrap } from '@vueuse/integrations/useFocusTrap';
```

2. Add ref for dialog content:
```typescript
const dialogCard = ref<HTMLElement | null>(null);
```

3. Initialize focus trap:
```typescript
const { activate, deactivate } = useFocusTrap(dialogCard, {
  immediate: false,
  allowOutsideClick: true,
  escapeDeactivates: true,
  returnFocusOnDeactivate: true,
});
```

4. Add dialog open/close handlers:
```typescript
async function onDialogOpen() {
  await nextTick();
  activate();
}

function onDialogClose() {
  deactivate();
}
```

5. Update template to use v-dialog events and add ref:
```vue
<v-dialog
  v-model="modelValue"
  max-width="600"
  persistent
  @update:model-value="$event ? onDialogOpen() : onDialogClose()"
>
  <v-card ref="dialogCard">
    <!-- existing content -->
  </v-card>
</v-dialog>
```

6. Ensure close() calls deactivate before closing:
```typescript
function close() {
  deactivate();
  modelValue.value = false;
}
```

Full updated script section:
```typescript
<script setup lang="ts">
import { ref, nextTick } from 'vue';
import { useFocusTrap } from '@vueuse/integrations/useFocusTrap';

const modelValue = defineModel<boolean>();

const activeTab = ref('general');
const dialogCard = ref<HTMLElement | null>(null);

const { activate, deactivate } = useFocusTrap(dialogCard, {
  immediate: false,
  allowOutsideClick: true,
  escapeDeactivates: true,
  returnFocusOnDeactivate: true,
});

async function onDialogOpen() {
  await nextTick();
  activate();
}

function close() {
  deactivate();
  modelValue.value = false;
}

function save() {
  // Content will be added in later phases
  close();
}
</script>
```

And update the template's v-dialog:
```vue
<v-dialog
  v-model="modelValue"
  max-width="600"
  persistent
  @update:model-value="(val) => val ? onDialogOpen() : undefined"
>
```

Note: The @update:model-value handler only needs to call onDialogOpen when dialog opens. Close is handled by the close() function which is called by the buttons.
  </action>
  <verify>
Manual test: Open settings dialog, Tab through all focusable elements, confirm focus stays within dialog, Escape closes dialog and returns focus to gear icon
  </verify>
  <done>SettingsDialog traps focus when open and returns focus on close</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes with no errors
2. `bun run dev` starts without console errors
3. Manual screen reader test (or browser accessibility inspector):
   - Navigate to Step 1, select gene -> hear "Selected gene: CFTR"
   - Click Next -> hear "Step 2: Status"
   - Continue to Step 4 -> hear "Step 4: Results" and calculation summary
4. Manual focus trap test:
   - Open Settings dialog
   - Tab repeatedly -> focus stays within dialog
   - Press Escape -> dialog closes, focus returns to gear icon
</verification>

<success_criteria>
- WizardStepper uses useAppAnnouncer for all dynamic announcements
- Screen reader users hear step changes, gene selection, loading, errors, and results
- SettingsDialog traps focus using useFocusTrap
- Escape key closes dialog (per CONTEXT.md decision)
- Focus returns to trigger element on dialog close
- Application builds and type-checks without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-seo-accessibility/07-03-SUMMARY.md`
</output>
