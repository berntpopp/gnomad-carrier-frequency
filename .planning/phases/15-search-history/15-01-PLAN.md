---
phase: 15-search-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/history.ts
  - src/types/index.ts
  - src/stores/useHistoryStore.ts
  - src/composables/useHistoryAutoSave.ts
  - src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "Completed calculations automatically saved when user reaches results step"
    - "History entries persist across browser sessions"
    - "Oldest entries automatically removed when limit exceeded"
  artifacts:
    - path: "src/types/history.ts"
      provides: "HistoryEntry, HistoryStoreState type definitions"
      exports: ["HistoryEntry", "HistoryStoreState", "HistorySettings"]
    - path: "src/stores/useHistoryStore.ts"
      provides: "Pinia store for history management"
      exports: ["useHistoryStore"]
    - path: "src/composables/useHistoryAutoSave.ts"
      provides: "Auto-save composable for wizard integration"
      exports: ["useHistoryAutoSave"]
  key_links:
    - from: "src/composables/useHistoryAutoSave.ts"
      to: "src/stores/useHistoryStore.ts"
      via: "store.addEntry() call"
      pattern: "historyStore\\.addEntry"
    - from: "src/stores/useHistoryStore.ts"
      to: "localStorage"
      via: "pinia-plugin-persistedstate"
      pattern: "persist.*carrier-freq-history"
---

<objective>
Create history infrastructure: types, Pinia store with persistence, and auto-save composable.

Purpose: Enable automatic saving of completed calculations to a persistent history that survives browser sessions, with automatic cleanup when the entry limit is exceeded.
Output: Types (HistoryEntry), Pinia store (useHistoryStore), auto-save composable (useHistoryAutoSave)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-search-history/15-RESEARCH.md
@.planning/phases/15-search-history/15-CONTEXT.md
@src/stores/useLogStore.ts
@src/composables/useWizard.ts
@src/types/wizard.ts
@src/types/filter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create history types</name>
  <files>src/types/history.ts, src/types/index.ts</files>
  <action>
Create `src/types/history.ts` with:

```typescript
import type { GnomadVersion } from '@/config';
import type { IndexPatientStatus, FrequencySource } from './wizard';
import type { FilterConfig } from './filter';

/**
 * Represents a saved calculation in history.
 * Contains all state needed to restore or display a previous calculation.
 */
export interface HistoryEntry {
  /** Unique identifier (UUID) */
  id: string;
  /** Unix timestamp when saved */
  timestamp: number;

  /** Gene information */
  gene: {
    ensembl_id: string;
    symbol: string;
  };

  /** Wizard state snapshot */
  indexStatus: IndexPatientStatus;
  frequencySource: FrequencySource;
  literatureFrequency: number | null;
  literaturePmid: string | null;

  /** Filter configuration snapshot */
  filterConfig: FilterConfig;

  /** Excluded variant IDs (reasons not stored for space) */
  excludedVariantIds: string[];

  /** Results snapshot for display without recalculation */
  results: {
    globalCarrierFrequency: number;
    qualifyingVariantCount: number;
    gnomadVersion: GnomadVersion;
  };
}

/**
 * History store settings
 */
export interface HistorySettings {
  /** Maximum number of entries to keep (FIFO cleanup) */
  maxEntries: number;
}

/**
 * History store state
 */
export interface HistoryStoreState {
  entries: HistoryEntry[];
  settings: HistorySettings;
}
```

Update `src/types/index.ts` to export from history.ts:
```typescript
export * from './history';
```
  </action>
  <verify>Run `bun run typecheck` - no type errors in history.ts</verify>
  <done>HistoryEntry, HistorySettings, HistoryStoreState types exported from src/types</done>
</task>

<task type="auto">
  <name>Task 2: Create history Pinia store</name>
  <files>src/stores/useHistoryStore.ts</files>
  <action>
Create `src/stores/useHistoryStore.ts` following the pattern from useLogStore.ts:

```typescript
import { defineStore } from 'pinia';
import type { HistoryEntry, HistoryStoreState } from '@/types';

export const useHistoryStore = defineStore('history', {
  state: (): HistoryStoreState => ({
    entries: [],
    settings: {
      maxEntries: 50, // Default from CONTEXT.md
    },
  }),

  getters: {
    /**
     * Get entry count
     */
    entryCount: (state): number => state.entries.length,

    /**
     * Check if history is empty
     */
    isEmpty: (state): boolean => state.entries.length === 0,

    /**
     * Get most recent entry (for duplicate detection)
     */
    mostRecent: (state): HistoryEntry | null =>
      state.entries.length > 0 ? state.entries[0] : null,

    /**
     * Group entries by calendar date for timeline display
     */
    groupedByDate: (state): Array<{ date: string; entries: HistoryEntry[] }> => {
      const groups = new Map<string, HistoryEntry[]>();

      for (const entry of state.entries) {
        const dateKey = new Date(entry.timestamp).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
        });

        if (!groups.has(dateKey)) {
          groups.set(dateKey, []);
        }
        groups.get(dateKey)!.push(entry);
      }

      return Array.from(groups.entries()).map(([date, entries]) => ({
        date,
        entries,
      }));
    },
  },

  actions: {
    /**
     * Add a new history entry with ring buffer management.
     * Entry is prepended (newest first).
     */
    addEntry(entry: Omit<HistoryEntry, 'id' | 'timestamp'>) {
      const newEntry: HistoryEntry = {
        ...entry,
        id: crypto.randomUUID(),
        timestamp: Date.now(),
      };

      this.entries.unshift(newEntry);

      // Ring buffer: remove oldest when exceeding max
      while (this.entries.length > this.settings.maxEntries) {
        this.entries.pop();
      }
    },

    /**
     * Delete a single entry by ID
     */
    deleteEntry(id: string) {
      const index = this.entries.findIndex(e => e.id === id);
      if (index > -1) {
        this.entries.splice(index, 1);
      }
    },

    /**
     * Clear all history entries
     */
    clearAll() {
      this.entries = [];
    },

    /**
     * Update max entries setting and enforce immediately
     */
    setMaxEntries(max: number) {
      // Clamp to reasonable range (10-200)
      this.settings.maxEntries = Math.max(10, Math.min(200, max));

      // Enforce new limit immediately
      while (this.entries.length > this.settings.maxEntries) {
        this.entries.pop();
      }
    },

    /**
     * Find entry by ID
     */
    getEntry(id: string): HistoryEntry | undefined {
      return this.entries.find(e => e.id === id);
    },
  },

  persist: {
    key: 'carrier-freq-history',
    storage: localStorage,
  },
});
```

Key patterns:
- Follow useLogStore ring buffer pattern
- Newest first (unshift)
- FIFO cleanup (pop oldest)
- Storage key follows project convention: carrier-freq-*
  </action>
  <verify>Run `bun run typecheck` - no errors. Check store is usable: import in a test component.</verify>
  <done>useHistoryStore Pinia store with persistence, ring buffer, groupedByDate getter</done>
</task>

<task type="auto">
  <name>Task 3: Create auto-save composable</name>
  <files>src/composables/useHistoryAutoSave.ts, src/composables/index.ts</files>
  <action>
Create `src/composables/useHistoryAutoSave.ts`:

```typescript
import { watch, toRaw } from 'vue';
import { useHistoryStore } from '@/stores/useHistoryStore';
import { useWizard } from './useWizard';
import { useCarrierFrequency } from './useCarrierFrequency';
import { useExclusionState } from './useExclusionState';

// Track if already initialized (singleton pattern)
let isInitialized = false;

/**
 * Composable that automatically saves completed calculations to history.
 *
 * Auto-save triggers when:
 * - User enters step 4 (results) from a different step
 * - Valid calculation result exists
 * - Not a duplicate of most recent entry (same gene within 30s)
 *
 * Call once at app root (App.vue) to initialize.
 */
export function useHistoryAutoSave() {
  const historyStore = useHistoryStore();
  const { state: wizardState } = useWizard();
  const { result, filterConfig, currentVersion } = useCarrierFrequency();
  const { excluded } = useExclusionState();

  function initialize() {
    if (isInitialized) return;
    isInitialized = true;

    // Watch for step changes to trigger auto-save
    watch(
      () => wizardState.currentStep,
      (newStep, oldStep) => {
        // Only save when entering results step from a different step
        if (newStep === 4 && oldStep !== 4) {
          saveCurrentCalculation();
        }
      }
    );
  }

  function saveCurrentCalculation() {
    // Must have valid gene and result
    if (!wizardState.gene || !result.value) {
      return;
    }

    // Must have valid carrier frequency
    if (result.value.globalCarrierFrequency === null) {
      return;
    }

    // Check for duplicate (same gene within 30 seconds)
    const mostRecent = historyStore.mostRecent;
    if (mostRecent) {
      const sameGene = mostRecent.gene.symbol === wizardState.gene.symbol;
      const recentEnough = Date.now() - mostRecent.timestamp < 30000;
      if (sameGene && recentEnough) {
        // Skip duplicate save
        return;
      }
    }

    // Build entry from current state
    historyStore.addEntry({
      gene: {
        ensembl_id: wizardState.gene.ensembl_id,
        symbol: wizardState.gene.symbol,
      },
      indexStatus: wizardState.indexStatus,
      frequencySource: wizardState.frequencySource,
      literatureFrequency: wizardState.literatureFrequency,
      literaturePmid: wizardState.literaturePmid,
      filterConfig: { ...toRaw(filterConfig.value) },
      excludedVariantIds: [...excluded.value],
      results: {
        globalCarrierFrequency: result.value.globalCarrierFrequency,
        qualifyingVariantCount: result.value.qualifyingVariantCount,
        gnomadVersion: currentVersion.value,
      },
    });
  }

  return {
    initialize,
    saveCurrentCalculation,
  };
}
```

Update `src/composables/index.ts` to export the new composable:
```typescript
export { useHistoryAutoSave } from './useHistoryAutoSave';
```

Key patterns:
- Singleton initialization (call once in App.vue)
- Watch wizard step transitions
- Duplicate detection: same gene + within 30s = skip
- Use toRaw() to avoid storing reactive proxies
  </action>
  <verify>Run `bun run typecheck` - no errors. Run `bun run lint` - no lint warnings.</verify>
  <done>useHistoryAutoSave composable with singleton initialization, auto-save on step 4, duplicate detection</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run build` succeeds
4. History types properly exported from src/types
5. Store uses correct persistence key pattern
6. Auto-save composable exports correctly
</verification>

<success_criteria>
- HistoryEntry type captures all required state (gene, filters, results, exclusions, timestamp)
- useHistoryStore has ring buffer with 50-entry default
- Store persists to localStorage with key 'carrier-freq-history'
- groupedByDate getter provides timeline-ready data structure
- useHistoryAutoSave triggers save only when entering step 4 with valid result
- Duplicate saves prevented (same gene within 30s)
</success_criteria>

<output>
After completion, create `.planning/phases/15-search-history/15-01-SUMMARY.md`
</output>
