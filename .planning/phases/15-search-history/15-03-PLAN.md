---
phase: 15-search-history
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/composables/useHistoryRestore.ts
  - src/composables/index.ts
  - src/components/SettingsDialog.vue
  - src/App.vue
autonomous: true

must_haves:
  truths:
    - "User can click history entry to restore full calculation state"
    - "User can clear all history from settings"
    - "User can configure maximum history entries in settings"
    - "History works offline using cached data"
  artifacts:
    - path: "src/composables/useHistoryRestore.ts"
      provides: "State restoration composable"
      exports: ["useHistoryRestore"]
    - path: "src/components/SettingsDialog.vue"
      provides: "History settings section with max entries and clear all"
      contains: "Clear History"
  key_links:
    - from: "src/composables/useHistoryRestore.ts"
      to: "src/composables/useWizard.ts"
      via: "state mutation"
      pattern: "wizardState\\."
    - from: "src/composables/useHistoryRestore.ts"
      to: "src/composables/useExclusionState.ts"
      via: "setExclusions call"
      pattern: "setExclusions"
    - from: "src/App.vue"
      to: "src/composables/useHistoryRestore.ts"
      via: "restoreFromHistory call"
      pattern: "restoreFromHistory"
---

<objective>
Create state restoration composable and settings integration for history management.

Purpose: Enable users to restore previous calculations with a single click, configure history limits, and clear all history. Ensure offline functionality by restoring wizard state and triggering data re-fetch.
Output: useHistoryRestore composable, SettingsDialog history section, App.vue restore integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-search-history/15-RESEARCH.md
@.planning/phases/15-search-history/15-CONTEXT.md
@.planning/phases/15-search-history/15-01-SUMMARY.md
@src/composables/useWizard.ts
@src/composables/useCarrierFrequency.ts
@src/composables/useExclusionState.ts
@src/composables/useGeneSearch.ts
@src/components/SettingsDialog.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useHistoryRestore composable</name>
  <files>src/composables/useHistoryRestore.ts, src/composables/index.ts</files>
  <action>
Create `src/composables/useHistoryRestore.ts`:

```typescript
import { ref } from 'vue';
import { useHistoryStore } from '@/stores/useHistoryStore';
import { useHistoryAutoSave } from './useHistoryAutoSave';
import { useWizard } from './useWizard';
import { useCarrierFrequency } from './useCarrierFrequency';
import { useExclusionState } from './useExclusionState';
import { useGeneSearch } from './useGeneSearch';
import type { HistoryEntry } from '@/types';

/**
 * Composable for restoring calculation state from history entries.
 *
 * Restoration process:
 * 1. Auto-save current state (if valid) to prevent data loss
 * 2. Restore wizard state (gene, index status, frequency source)
 * 3. Trigger gene data fetch
 * 4. Restore filter configuration
 * 5. Restore exclusions
 * 6. Navigate to results step
 */
export function useHistoryRestore() {
  const historyStore = useHistoryStore();
  const { saveCurrentCalculation } = useHistoryAutoSave();
  const { state: wizardState, goToStep } = useWizard();
  const { setGeneSymbol, setFilterConfig } = useCarrierFrequency();
  const { setExclusions, resetForGene } = useExclusionState();
  const geneSearch = useGeneSearch();

  const isRestoring = ref(false);

  /**
   * Restore full application state from a history entry.
   *
   * @param entryId - UUID of the history entry to restore
   * @returns true if restoration succeeded, false if entry not found
   */
  async function restoreFromHistory(entryId: string): Promise<boolean> {
    const entry = historyStore.getEntry(entryId);
    if (!entry) {
      console.warn('History entry not found:', entryId);
      return false;
    }

    isRestoring.value = true;

    try {
      // Step 1: Auto-save current state before restoring (per CONTEXT.md)
      // This prevents accidental data loss when browsing history
      saveCurrentCalculation();

      // Step 2: Restore gene
      // Update wizard state with gene info
      wizardState.gene = {
        ensembl_id: entry.gene.ensembl_id,
        symbol: entry.gene.symbol,
      };

      // Reset exclusions for this gene first
      resetForGene(entry.gene.symbol);

      // Trigger gene search/selection which fetches variant data
      geneSearch.selectGene(wizardState.gene);

      // Set gene symbol in carrier frequency composable (triggers data fetch)
      setGeneSymbol(entry.gene.symbol);

      // Step 3: Restore wizard state
      wizardState.indexStatus = entry.indexStatus;
      wizardState.frequencySource = entry.frequencySource;
      wizardState.literatureFrequency = entry.literatureFrequency;
      wizardState.literaturePmid = entry.literaturePmid;

      // Step 4: Restore filter configuration
      // This updates the session filter config, not the saved defaults
      setFilterConfig({ ...entry.filterConfig });

      // Step 5: Restore exclusions
      if (entry.excludedVariantIds.length > 0) {
        setExclusions(entry.excludedVariantIds);
      }

      // Step 6: Navigate to results step
      // Use goToStep to bypass validation since we're restoring valid state
      wizardState.currentStep = 4;

      return true;
    } catch (error) {
      console.error('Failed to restore from history:', error);
      return false;
    } finally {
      isRestoring.value = false;
    }
  }

  return {
    isRestoring,
    restoreFromHistory,
  };
}
```

Update `src/composables/index.ts` to export:
```typescript
export { useHistoryRestore } from './useHistoryRestore';
```

Key patterns:
- Auto-save current state before restore (prevents data loss)
- Restore in correct order: gene -> wizard state -> filters -> exclusions -> navigate
- Use existing composables for state mutations
- Handle errors gracefully
  </action>
  <verify>Run `bun run typecheck` and `bun run lint` - no errors</verify>
  <done>useHistoryRestore composable with full state restoration from history entry</done>
</task>

<task type="auto">
  <name>Task 2: Add history settings section to SettingsDialog</name>
  <files>src/components/SettingsDialog.vue</files>
  <action>
Update `src/components/SettingsDialog.vue`:

1. Import useHistoryStore:
```typescript
import { useHistoryStore } from '@/stores/useHistoryStore';
```

2. Add in script setup:
```typescript
const historyStore = useHistoryStore();
```

3. Add History section in the "general" tab AFTER the "Log Settings" section (before closing v-tabs-window-item):

```vue
<!-- History Settings Section -->
<v-card
  variant="outlined"
  class="mb-4"
>
  <v-card-title class="text-subtitle-1">
    <v-icon
      start
      size="small"
    >
      mdi-history
    </v-icon>
    Search History
  </v-card-title>

  <v-card-text>
    <!-- Entry count and storage info -->
    <div class="d-flex align-center justify-space-between mb-4">
      <div class="text-body-2">
        <strong>Entries:</strong> {{ historyStore.entryCount }}
      </div>
      <v-btn
        v-if="!historyStore.isEmpty"
        color="error"
        variant="text"
        size="small"
        @click="confirmClearHistory"
      >
        Clear History
      </v-btn>
    </div>

    <!-- Max entries slider -->
    <v-slider
      v-model="historyMaxEntries"
      :min="10"
      :max="200"
      :step="10"
      label="Maximum entries"
      thumb-label
      class="mb-2"
      :density="smAndDown ? 'default' : 'compact'"
      :hide-details="smAndDown"
    >
      <template #append>
        <span class="text-body-2 text-medium-emphasis">
          {{ historyMaxEntries }}
        </span>
      </template>
    </v-slider>

    <div class="text-caption text-medium-emphasis">
      Oldest entries are automatically removed when the limit is exceeded.
    </div>
  </v-card-text>
</v-card>

<!-- Clear History Confirmation Dialog -->
<v-dialog
  v-model="showClearHistoryDialog"
  max-width="400"
>
  <v-card>
    <v-card-title>Clear Search History?</v-card-title>
    <v-card-text>
      This will permanently delete all {{ historyStore.entryCount }} history entries.
      This action cannot be undone.
    </v-card-text>
    <v-card-actions>
      <v-spacer />
      <v-btn
        variant="text"
        @click="showClearHistoryDialog = false"
      >
        Cancel
      </v-btn>
      <v-btn
        color="error"
        variant="flat"
        @click="clearAllHistory"
      >
        Clear All
      </v-btn>
    </v-card-actions>
  </v-card>
</v-dialog>
```

4. Add state and methods in script setup:
```typescript
// History settings
const showClearHistoryDialog = ref(false);

const historyMaxEntries = computed({
  get: () => historyStore.settings.maxEntries,
  set: (value: number) => historyStore.setMaxEntries(value),
});

function confirmClearHistory() {
  showClearHistoryDialog.value = true;
}

function clearAllHistory() {
  historyStore.clearAll();
  showClearHistoryDialog.value = false;
}
```

Note: SettingsDialog already imports useDisplay for smAndDown, so mobile density is already available.
  </action>
  <verify>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run dev` - open Settings, see History section in General tab
4. Max entries slider works (10-200 range)
5. Clear History button shows confirmation dialog
6. Confirming clears all entries
  </verify>
  <done>SettingsDialog has History section with entry count, max entries slider, clear all with confirmation</done>
</task>

<task type="auto">
  <name>Task 3: Wire restore functionality in App.vue</name>
  <files>src/App.vue</files>
  <action>
Update `src/App.vue` to integrate history restoration:

1. Import useHistoryRestore:
```typescript
import { useHistoryRestore } from '@/composables';
```

2. Add in script setup:
```typescript
// History restore
const { restoreFromHistory, isRestoring } = useHistoryRestore();
```

3. Update handleHistoryRestore function:
```typescript
async function handleHistoryRestore(id: string) {
  const success = await restoreFromHistory(id);
  if (!success) {
    // Could show error toast here, but silent fail is acceptable
    // Entry may have been deleted or corrupted
    console.warn('Failed to restore history entry:', id);
  }
}
```

4. Optional: Add loading indicator during restore (similar to URL restore).
   The isRestoringFromUrl loading state can be extended or a new one added.
   For simplicity, the restoration is fast enough that no indicator is needed.

The final App.vue should have:
- useHistoryAutoSave initialized (from Plan 02)
- useHistoryRestore for handling restore events
- HistoryDrawer with @restore="handleHistoryRestore"
  </action>
  <verify>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run build` succeeds
4. Full flow test:
   a. Search for a gene (e.g., "CFTR")
   b. Complete wizard to results step
   c. Open history drawer - entry appears
   d. Click different gene search
   e. Open history, click previous entry
   f. State restores: gene, filters, exclusions, results shown
5. Offline test:
   a. Complete a calculation while online
   b. Go offline (DevTools Network tab)
   c. Open history, click entry
   d. State restores (may show cached data or offline indicator)
  </verify>
  <done>App.vue wires useHistoryRestore, clicking history entry restores full state</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. `bun run build` succeeds
4. Click history entry - full state restored (HIST-04)
5. Gene, filters, exclusions all restored correctly
6. Settings shows History section (HIST-08)
7. Max entries slider adjusts limit (HIST-07)
8. Clear History removes all entries (HIST-08)
9. Auto-save preserves current work before restore (CONTEXT.md decision)
10. Works offline - state restores from entry data (HIST-10)
</verification>

<success_criteria>
- Clicking history entry restores gene, wizard state, filters, exclusions (HIST-04)
- State restoration triggers data fetch for fresh results
- Current work auto-saved before restore (prevents data loss)
- Settings has History section with entry count (HIST-08)
- Max entries configurable via slider (HIST-07)
- Clear History requires confirmation then removes all (HIST-08)
- History persists across sessions via localStorage (HIST-09)
- Works offline using stored entry data (HIST-10)
</success_criteria>

<output>
After completion, create `.planning/phases/15-search-history/15-03-SUMMARY.md`
</output>
