---
phase: 09-clingen-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/clingen.ts
  - src/stores/useClingenStore.ts
  - src/composables/useClingenValidity.ts
autonomous: true

must_haves:
  truths:
    - "App can fetch ClinGen gene-disease validity CSV"
    - "ClinGen data is cached with timestamp"
    - "Cache expiry is checked (30 days)"
    - "Gene can be looked up for AR association"
  artifacts:
    - path: "src/types/clingen.ts"
      provides: "ClinGen type definitions"
      exports: ["ClingenEntry", "ClingenCacheState", "ClingenValidityResult"]
    - path: "src/stores/useClingenStore.ts"
      provides: "ClinGen data cache store with persistence"
      exports: ["useClingenStore"]
    - path: "src/composables/useClingenValidity.ts"
      provides: "ClinGen fetch/lookup composable"
      exports: ["useClingenValidity"]
  key_links:
    - from: "src/composables/useClingenValidity.ts"
      to: "src/stores/useClingenStore.ts"
      via: "store access for cache"
      pattern: "useClingenStore"
    - from: "src/stores/useClingenStore.ts"
      to: "localStorage"
      via: "pinia-plugin-persistedstate"
      pattern: "persist:"
---

<objective>
Create ClinGen gene-disease validity infrastructure with typed data model, persistent cache store, and composable for fetching/querying ClinGen CSV data.

Purpose: Enable app to check if a gene has validated AR (autosomal recessive) association per ClinGen, which is required for clinical warnings (CLIN-01, CLIN-02).

Output: Types, store, and composable that fetch ClinGen CSV, parse it, cache with 30-day expiry, and provide gene lookup functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-clingen-documentation/09-RESEARCH.md

# Existing patterns to follow
@src/stores/useFilterStore.ts
@src/types/filter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClinGen type definitions</name>
  <files>src/types/clingen.ts, src/types/index.ts</files>
  <action>
Create `src/types/clingen.ts` with typed interfaces:

```typescript
/**
 * Single ClinGen gene-disease validity entry
 * Maps to CSV columns from https://search.clinicalgenome.org/kb/gene-validity/download
 */
export interface ClingenEntry {
  geneSymbol: string;       // Column 0: GENE SYMBOL
  hgncId: string;           // Column 1: GENE ID (HGNC)
  diseaseLabel: string;     // Column 2: DISEASE LABEL
  mondoId: string;          // Column 3: DISEASE ID (MONDO)
  moi: string;              // Column 4: MOI (Mode of Inheritance)
  classification: string;   // Column 5: CLASSIFICATION
  onlineReport: string;     // Column 7: ONLINE REPORT (URL)
  classificationDate: string; // Column 8: CLASSIFICATION DATE
  gcep: string;             // Column 9: GCEP (expert panel)
}

/**
 * Cache state for ClinGen data in Pinia store
 */
export interface ClingenCacheState {
  data: ClingenEntry[] | null;
  lastFetched: number | null;  // Unix timestamp in ms
  error: string | null;
}

/**
 * Result of looking up a gene in ClinGen data
 */
export interface ClingenValidityResult {
  found: boolean;
  hasAutosomalRecessive: boolean;
  entries: ClingenEntry[];  // All entries for this gene
  arEntries: ClingenEntry[]; // Only AR entries
}

/**
 * Cache expiry constant (30 days in milliseconds)
 */
export const CLINGEN_CACHE_EXPIRY_MS = 30 * 24 * 60 * 60 * 1000;
```

Export from `src/types/index.ts`:
- Add export for ClingenEntry, ClingenCacheState, ClingenValidityResult, CLINGEN_CACHE_EXPIRY_MS
  </action>
  <verify>Run `bun run typecheck` - no errors related to clingen types</verify>
  <done>ClinGen types exported from src/types/index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create ClinGen cache store</name>
  <files>src/stores/useClingenStore.ts</files>
  <action>
Create `src/stores/useClingenStore.ts` following the useFilterStore.ts pattern:

```typescript
import { defineStore } from 'pinia';
import type { ClingenCacheState, ClingenEntry, ClingenValidityResult } from '@/types';
import { CLINGEN_CACHE_EXPIRY_MS } from '@/types';

export const useClingenStore = defineStore('clingen', {
  state: (): ClingenCacheState => ({
    data: null,
    lastFetched: null,
    error: null,
  }),

  getters: {
    /**
     * Check if cache is expired (> 30 days old) or missing
     */
    isExpired: (state): boolean => {
      if (!state.lastFetched || !state.data) return true;
      return Date.now() - state.lastFetched > CLINGEN_CACHE_EXPIRY_MS;
    },

    /**
     * Check if cache has data (regardless of expiry)
     */
    hasData: (state): boolean => {
      return state.data !== null && state.data.length > 0;
    },

    /**
     * Get human-readable cache age
     */
    cacheAge: (state): string => {
      if (!state.lastFetched) return 'Never fetched';
      const days = Math.floor((Date.now() - state.lastFetched) / (24 * 60 * 60 * 1000));
      if (days === 0) return 'Today';
      if (days === 1) return '1 day ago';
      return `${days} days ago`;
    },

    /**
     * Total number of entries in cache
     */
    entryCount: (state): number => {
      return state.data?.length ?? 0;
    },
  },

  actions: {
    /**
     * Set cache data with timestamp
     */
    setData(entries: ClingenEntry[]) {
      this.data = entries;
      this.lastFetched = Date.now();
      this.error = null;
    },

    /**
     * Set error state
     */
    setError(message: string) {
      this.error = message;
    },

    /**
     * Clear cache (for manual refresh)
     */
    clearCache() {
      this.data = null;
      this.lastFetched = null;
      this.error = null;
    },

    /**
     * Look up gene validity in cached data
     */
    getGeneValidity(geneSymbol: string): ClingenValidityResult {
      if (!this.data) {
        return { found: false, hasAutosomalRecessive: false, entries: [], arEntries: [] };
      }

      const normalizedSymbol = geneSymbol.toUpperCase().trim();
      const entries = this.data.filter(
        (e) => e.geneSymbol.toUpperCase() === normalizedSymbol
      );

      // Check for AR inheritance patterns
      const arEntries = entries.filter((e) => {
        const moi = e.moi.toLowerCase();
        return moi.includes('recessive') || moi === 'ar';
      });

      return {
        found: entries.length > 0,
        hasAutosomalRecessive: arEntries.length > 0,
        entries,
        arEntries,
      };
    },
  },

  persist: {
    key: 'clingen-cache',
    storage: localStorage,
  },
});
```
  </action>
  <verify>Run `bun run typecheck` - store compiles without errors</verify>
  <done>ClinGen store created with cache management, expiry checking, and gene lookup</done>
</task>

<task type="auto">
  <name>Task 3: Create ClinGen validity composable</name>
  <files>src/composables/useClingenValidity.ts, src/composables/index.ts</files>
  <action>
Create `src/composables/useClingenValidity.ts`:

```typescript
import { ref, computed, type Ref, type ComputedRef } from 'vue';
import { useClingenStore } from '@/stores/useClingenStore';
import type { ClingenEntry, ClingenValidityResult } from '@/types';

const CLINGEN_CSV_URL = 'https://search.clinicalgenome.org/kb/gene-validity/download';

export interface UseClingenValidityReturn {
  // State
  isLoading: Ref<boolean>;
  error: ComputedRef<string | null>;

  // Cache info
  isExpired: ComputedRef<boolean>;
  hasData: ComputedRef<boolean>;
  cacheAge: ComputedRef<string>;
  entryCount: ComputedRef<number>;

  // Actions
  fetchData: () => Promise<void>;
  refreshCache: () => Promise<void>;
  checkGene: (geneSymbol: string) => ClingenValidityResult;
}

/**
 * Parse ClinGen CSV text into typed entries
 * CSV structure: GENE SYMBOL, GENE ID (HGNC), DISEASE LABEL, DISEASE ID (MONDO), MOI, SOP, CLASSIFICATION, ONLINE REPORT, CLASSIFICATION DATE, GCEP, ...
 */
function parseClingenCSV(csvText: string): ClingenEntry[] {
  const lines = csvText.split('\n');

  // Skip header row, filter empty lines
  return lines
    .slice(1)
    .filter((line) => line.trim().length > 0)
    .map((line) => {
      // Handle CSV with potential quoted fields
      const values = parseCSVLine(line);
      return {
        geneSymbol: values[0]?.trim().toUpperCase() ?? '',
        hgncId: values[1]?.trim() ?? '',
        diseaseLabel: values[2]?.trim() ?? '',
        mondoId: values[3]?.trim() ?? '',
        moi: values[4]?.trim() ?? '',
        classification: values[5]?.trim() ?? '',
        onlineReport: values[7]?.trim() ?? '',
        classificationDate: values[8]?.trim() ?? '',
        gcep: values[9]?.trim() ?? '',
      };
    })
    .filter((entry) => entry.geneSymbol.length > 0);
}

/**
 * Parse a single CSV line, handling quoted fields
 */
function parseCSVLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  result.push(current); // Push last field
  return result;
}

export function useClingenValidity(): UseClingenValidityReturn {
  const store = useClingenStore();
  const isLoading = ref(false);

  const fetchData = async (): Promise<void> => {
    // Skip if cache is valid
    if (store.hasData && !store.isExpired) {
      return;
    }

    isLoading.value = true;
    store.setError(''); // Clear previous errors

    try {
      const response = await fetch(CLINGEN_CSV_URL);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const csvText = await response.text();
      const entries = parseClingenCSV(csvText);

      if (entries.length === 0) {
        throw new Error('No valid entries parsed from ClinGen CSV');
      }

      store.setData(entries);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch ClinGen data';
      store.setError(message);
      console.error('[ClinGen] Fetch error:', message);
    } finally {
      isLoading.value = false;
    }
  };

  const refreshCache = async (): Promise<void> => {
    store.clearCache();
    await fetchData();
  };

  const checkGene = (geneSymbol: string): ClingenValidityResult => {
    return store.getGeneValidity(geneSymbol);
  };

  return {
    isLoading,
    error: computed(() => store.error),
    isExpired: computed(() => store.isExpired),
    hasData: computed(() => store.hasData),
    cacheAge: computed(() => store.cacheAge),
    entryCount: computed(() => store.entryCount),
    fetchData,
    refreshCache,
    checkGene,
  };
}
```

Export from `src/composables/index.ts`:
- Add `export { useClingenValidity } from './useClingenValidity';`
  </action>
  <verify>Run `bun run typecheck` - composable compiles, run `bun run lint` - no errors</verify>
  <done>ClinGen composable fetches CSV, parses it, caches in store, provides gene lookup</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. Types are exported from src/types/index.ts
4. Composable is exported from src/composables/index.ts
5. Store uses persist pattern consistent with useFilterStore.ts
</verification>

<success_criteria>
- ClinGen types define entry structure and cache state
- Store persists data with 30-day expiry tracking
- Composable can fetch ClinGen CSV and parse it
- Gene lookup returns AR association status
- Cache can be manually cleared for refresh
</success_criteria>

<output>
After completion, create `.planning/phases/09-clingen-documentation/09-01-SUMMARY.md`
</output>
