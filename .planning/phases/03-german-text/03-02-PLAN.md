---
phase: 03-german-text
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/stores/useTemplateStore.ts
  - src/main.ts
  - src/composables/useTextGenerator.ts
  - src/composables/index.ts
autonomous: true

must_haves:
  truths:
    - "Template customizations persist across page refresh"
    - "Language preference persists across sessions"
    - "Generated text combines enabled sections with variable interpolation"
    - "Source attribution formats correctly for gnomAD, literature, and default"
  artifacts:
    - path: "src/stores/useTemplateStore.ts"
      provides: "Pinia store for template state and persistence"
      exports: ["useTemplateStore"]
    - path: "src/composables/useTextGenerator.ts"
      provides: "Text generation composable combining store, templates, context"
      exports: ["useTextGenerator"]
    - path: "src/main.ts"
      provides: "Pinia plugin integration"
      contains: "createPinia"
  key_links:
    - from: "src/main.ts"
      to: "pinia"
      via: "app.use(pinia)"
      pattern: "app\\.use\\(pinia\\)"
    - from: "src/composables/useTextGenerator.ts"
      to: "src/stores/useTemplateStore.ts"
      via: "useTemplateStore import"
      pattern: "useTemplateStore\\(\\)"
    - from: "src/composables/useTextGenerator.ts"
      to: "src/utils/template-renderer.ts"
      via: "renderTemplate import"
      pattern: "renderTemplate\\("
---

<objective>
Create the Pinia store for template management with localStorage persistence, and the useTextGenerator composable that combines templates with calculation context.

Purpose: Enable template customization persistence and provide the main API for components to generate clinical text.
Output: Working store with persistence and composable ready for UI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-german-text/03-CONTEXT.md
@.planning/phases/03-german-text/03-RESEARCH.md
@.planning/phases/03-german-text/03-01-SUMMARY.md

@src/main.ts
@src/composables/index.ts
@src/types/text.ts
@src/utils/template-renderer.ts
@src/config/templates/de.json
@src/config/templates/en.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pinia and persistence plugin</name>
  <files>package.json</files>
  <action>
Install Pinia and the persistence plugin:

```bash
npm install pinia pinia-plugin-persistedstate
```

These are the standard Vue 3 state management solution (Pinia is official) and the de-facto persistence plugin.

No code changes in this task - just dependency installation.
  </action>
  <verify>Run `npm ls pinia pinia-plugin-persistedstate` to confirm both packages installed</verify>
  <done>Both pinia and pinia-plugin-persistedstate appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create Pinia store and integrate into main.ts</name>
  <files>src/stores/useTemplateStore.ts, src/main.ts</files>
  <action>
**Create src/stores/useTemplateStore.ts:**

```typescript
import { defineStore } from 'pinia';
import type { Perspective, GenderStyle, TemplateConfig } from '@/types';
import defaultDe from '@/config/templates/de.json';
import defaultEn from '@/config/templates/en.json';

// Type assertion for imported JSON
const templateDe = defaultDe as TemplateConfig;
const templateEn = defaultEn as TemplateConfig;

interface TemplateStoreState {
  language: 'de' | 'en';
  genderStyle: GenderStyle;
  enabledSections: Record<Perspective, string[]>; // Which sections are enabled per perspective
  customSections: Record<string, string>; // section key -> custom template override
}

export const useTemplateStore = defineStore('templates', {
  state: (): TemplateStoreState => ({
    language: detectBrowserLanguage(),
    genderStyle: '*',
    enabledSections: {
      affected: ['geneIntro', 'inheritance', 'carrierFrequency', 'recurrenceRisk', 'recommendation'],
      carrier: ['geneIntro', 'inheritance', 'carrierFrequency', 'recurrenceRisk', 'recommendation'],
      familyMember: ['geneIntro', 'inheritance', 'carrierFrequency', 'recurrenceRisk', 'recommendation'],
    },
    customSections: {},
  }),

  getters: {
    defaultTemplates: (state): TemplateConfig => {
      return state.language === 'de' ? templateDe : templateEn;
    },

    genderSuffix: (state): string => {
      switch (state.genderStyle) {
        case '*': return '*innen';
        case ':': return ':innen';
        case '/': return '/-innen';
        case 'traditional': return 'innen';
        default: return '*innen';
      }
    },
  },

  actions: {
    setLanguage(lang: 'de' | 'en') {
      this.language = lang;
    },

    setGenderStyle(style: GenderStyle) {
      this.genderStyle = style;
    },

    toggleSection(perspective: Perspective, sectionId: string) {
      const sections = this.enabledSections[perspective];
      const index = sections.indexOf(sectionId);
      if (index > -1) {
        sections.splice(index, 1);
      } else {
        sections.push(sectionId);
      }
    },

    setSectionEnabled(perspective: Perspective, sectionId: string, enabled: boolean) {
      const sections = this.enabledSections[perspective];
      const index = sections.indexOf(sectionId);
      if (enabled && index === -1) {
        sections.push(sectionId);
      } else if (!enabled && index > -1) {
        sections.splice(index, 1);
      }
    },

    setCustomSection(sectionKey: string, template: string) {
      this.customSections[sectionKey] = template;
    },

    resetCustomSection(sectionKey: string) {
      delete this.customSections[sectionKey];
    },

    resetAllCustomizations() {
      this.customSections = {};
    },
  },

  persist: {
    key: 'carrier-freq-templates',
    storage: localStorage,
  },
});

function detectBrowserLanguage(): 'de' | 'en' {
  const browserLang = navigator.language.split('-')[0];
  return browserLang === 'de' ? 'de' : 'en';
}
```

**Update src/main.ts to integrate Pinia:**

Add Pinia setup BEFORE Vuetify in the imports and app.use() chain:

```typescript
import { createApp } from 'vue'

// Pinia
import { createPinia } from 'pinia';
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate';

// Vuetify
import 'vuetify/styles'
import '@mdi/font/css/materialdesignicons.css'
import { createVuetify } from 'vuetify'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'

import App from './App.vue'
import { graphqlClient } from '@/api'

// Pinia setup
const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);

// Vuetify setup
const vuetify = createVuetify({
  components,
  directives,
  theme: {
    defaultTheme: 'light',
    themes: {
      light: {
        dark: false,
        colors: {
          primary: '#1976D2',
          secondary: '#424242',
        }
      }
    }
  }
})

const app = createApp(App)
app.use(pinia)  // Must be before other plugins that might use stores
app.use(vuetify)
app.use(graphqlClient)
app.mount('#app')
```

Key points:
- Pinia must be installed before components that use stores mount
- Persistence plugin uses localStorage with key 'carrier-freq-templates'
- Browser language detection defaults to English if not German
  </action>
  <verify>Run `npm run dev` and check browser console for no errors. Check localStorage in DevTools - after interacting with store, 'carrier-freq-templates' key should appear.</verify>
  <done>Pinia store created, integrated into main.ts, persistence working (data survives page refresh)</done>
</task>

<task type="auto">
  <name>Task 3: Create useTextGenerator composable</name>
  <files>src/composables/useTextGenerator.ts, src/composables/index.ts</files>
  <action>
**Create src/composables/useTextGenerator.ts:**

```typescript
import { computed } from 'vue';
import { useTemplateStore } from '@/stores/useTemplateStore';
import { renderTemplate } from '@/utils/template-renderer';
import type {
  Perspective,
  TemplateContext,
  FrequencySource,
  IndexPatientStatus,
  CarrierFrequencyResult,
} from '@/types';
import { config } from '@/config';

interface TextGeneratorInput {
  result: CarrierFrequencyResult | null;
  frequencySource: FrequencySource;
  indexStatus: IndexPatientStatus;
  literatureFrequency: number | null;
  literaturePmid: string | null;
  usingDefault: boolean;
}

export function useTextGenerator(input: () => TextGeneratorInput) {
  const store = useTemplateStore();

  // Build template context from calculation results
  const templateContext = computed((): TemplateContext | null => {
    const data = input();
    if (!data.result) return null;

    const effectiveFrequency = getEffectiveFrequency(data);
    if (effectiveFrequency === null) return null;

    const divisor = data.indexStatus === 'heterozygous' ? 4 : 2;
    const recurrenceRisk = effectiveFrequency / divisor;

    return {
      gene: data.result.gene,
      carrierFrequency: formatFrequencyForLocale(effectiveFrequency, store.language),
      carrierFrequencyRatio: formatRatio(effectiveFrequency),
      recurrenceRiskPercent: formatPercentForLocale(recurrenceRisk, store.language),
      recurrenceRiskRatio: formatRatio(recurrenceRisk),
      source: formatSourceAttribution(data, store.language),
      indexStatus: data.indexStatus === 'heterozygous' ? 'carrier' : 'affected',
      genderSuffix: store.genderSuffix,
      accessDate: formatAccessDate(store.language),
    };
  });

  // Generate text for a given perspective
  const generateText = (perspective: Perspective): string => {
    const context = templateContext.value;
    if (!context) return '';

    const templates = store.defaultTemplates;
    const perspectiveConfig = templates.perspectives[perspective];
    if (!perspectiveConfig) return '';

    const enabledSections = store.enabledSections[perspective];
    const sectionOrder = ['geneIntro', 'inheritance', 'carrierFrequency', 'recurrenceRisk', 'populationContext', 'founderEffect', 'sourceCitation', 'recommendation'];

    const textParts: string[] = [];

    for (const sectionId of sectionOrder) {
      if (!enabledSections.includes(sectionId)) continue;

      const section = perspectiveConfig.sections[sectionId];
      if (!section) continue;

      // Use custom template if exists, otherwise default
      const customKey = `${perspective}.${sectionId}`;
      const template = store.customSections[customKey] ?? section.template;

      const rendered = renderTemplate(template, context);
      if (rendered.trim()) {
        textParts.push(rendered);
      }
    }

    return textParts.join(' ');
  };

  // Get all available sections for a perspective (for UI toggles)
  const getSections = (perspective: Perspective) => {
    const templates = store.defaultTemplates;
    const perspectiveConfig = templates.perspectives[perspective];
    if (!perspectiveConfig) return [];

    return Object.entries(perspectiveConfig.sections).map(([id, section]) => ({
      id,
      label: section.label,
      enabled: store.enabledSections[perspective].includes(id),
    }));
  };

  return {
    templateContext,
    generateText,
    getSections,
    language: computed(() => store.language),
    genderStyle: computed(() => store.genderStyle),
    setLanguage: store.setLanguage,
    setGenderStyle: store.setGenderStyle,
    toggleSection: store.toggleSection,
  };
}

// Helper functions
function getEffectiveFrequency(data: TextGeneratorInput): number | null {
  switch (data.frequencySource) {
    case 'gnomad':
      return data.result?.globalCarrierFrequency ?? null;
    case 'literature':
      return data.literatureFrequency;
    case 'default':
      return config.settings.defaultCarrierFrequency;
    default:
      return null;
  }
}

function formatFrequencyForLocale(freq: number, lang: 'de' | 'en'): string {
  const percent = freq * 100;
  return percent.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }) + '%';
}

function formatPercentForLocale(value: number, lang: 'de' | 'en'): string {
  const percent = value * 100;
  return percent.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }) + '%';
}

function formatRatio(value: number): string {
  if (value <= 0) return 'N/A';
  return `1:${Math.round(1 / value).toLocaleString()}`;
}

function formatAccessDate(lang: 'de' | 'en'): string {
  const now = new Date();
  if (lang === 'de') {
    return now.toLocaleDateString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  }
  return now.toLocaleDateString('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric',
  });
}

function formatSourceAttribution(data: TextGeneratorInput, lang: 'de' | 'en'): string {
  const accessDate = formatAccessDate(lang);

  switch (data.frequencySource) {
    case 'gnomad':
      if (data.usingDefault) {
        return lang === 'de'
          ? '(Standardannahme mangels gnomAD-Daten)'
          : '(default assumption, no gnomAD data)';
      }
      return lang === 'de'
        ? `(gnomAD v4, https://gnomad.broadinstitute.org, abgerufen am ${accessDate})`
        : `(gnomAD v4, https://gnomad.broadinstitute.org, accessed ${accessDate})`;

    case 'literature':
      // Format: (Author et al. year, PMID: xxx)
      // Since we only have PMID, format as (PMID: xxx)
      return `(PMID: ${data.literaturePmid})`;

    case 'default':
      return lang === 'de'
        ? '(Standardannahme)'
        : '(default assumption)';

    default:
      return '';
  }
}

export type UseTextGeneratorReturn = ReturnType<typeof useTextGenerator>;
```

**Update src/composables/index.ts to export:**

Add the new composable to the barrel export:

```typescript
export { useTextGenerator } from './useTextGenerator';
export type { UseTextGeneratorReturn } from './useTextGenerator';
```
  </action>
  <verify>Run `npx vue-tsc --noEmit` to verify types compile. The composable should be importable from @/composables.</verify>
  <done>useTextGenerator composable created, exported from barrel, integrates store + renderer + context building</done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. `npx vue-tsc --noEmit` passes
3. localStorage shows 'carrier-freq-templates' key after store interaction
4. Language detection works (defaults based on browser)
5. useTextGenerator can be imported from @/composables
</verification>

<success_criteria>
- Pinia + persistence plugin installed and configured
- Store persists language, genderStyle, enabledSections to localStorage
- useTextGenerator builds context from calculation results
- Source attribution formats correctly for all three sources (gnomAD, literature, default)
- German numbers use comma (0,25%), English use period (0.25%)
</success_criteria>

<output>
After completion, create `.planning/phases/03-german-text/03-02-SUMMARY.md`
</output>
